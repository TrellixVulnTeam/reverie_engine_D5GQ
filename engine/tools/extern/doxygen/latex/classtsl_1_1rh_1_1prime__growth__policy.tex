\hypertarget{classtsl_1_1rh_1_1prime__growth__policy}{}\section{tsl\+::rh\+::prime\+\_\+growth\+\_\+policy Class Reference}
\label{classtsl_1_1rh_1_1prime__growth__policy}\index{tsl::rh::prime\_growth\_policy@{tsl::rh::prime\_growth\_policy}}


{\ttfamily \#include $<$robin\+\_\+growth\+\_\+policy.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classtsl_1_1rh_1_1prime__growth__policy_ad1bd24ab6ae0f9015580f1e2e9bc0d73}\label{classtsl_1_1rh_1_1prime__growth__policy_ad1bd24ab6ae0f9015580f1e2e9bc0d73}} 
{\bfseries prime\+\_\+growth\+\_\+policy} (std\+::size\+\_\+t \&min\+\_\+bucket\+\_\+count\+\_\+in\+\_\+out)
\item 
\mbox{\Hypertarget{classtsl_1_1rh_1_1prime__growth__policy_a0347fd6283adcd8827100dc086497131}\label{classtsl_1_1rh_1_1prime__growth__policy_a0347fd6283adcd8827100dc086497131}} 
std\+::size\+\_\+t {\bfseries bucket\+\_\+for\+\_\+hash} (std\+::size\+\_\+t hash) const noexcept
\item 
\mbox{\Hypertarget{classtsl_1_1rh_1_1prime__growth__policy_a3682e02287eba843471537f582ca8156}\label{classtsl_1_1rh_1_1prime__growth__policy_a3682e02287eba843471537f582ca8156}} 
std\+::size\+\_\+t {\bfseries next\+\_\+bucket\+\_\+count} () const
\item 
\mbox{\Hypertarget{classtsl_1_1rh_1_1prime__growth__policy_adb93687c90dad0e1b6ae31f7443d2a33}\label{classtsl_1_1rh_1_1prime__growth__policy_adb93687c90dad0e1b6ae31f7443d2a33}} 
std\+::size\+\_\+t {\bfseries max\+\_\+bucket\+\_\+count} () const
\item 
\mbox{\Hypertarget{classtsl_1_1rh_1_1prime__growth__policy_aef14e2429e8bf134e8aeb40de6ed9856}\label{classtsl_1_1rh_1_1prime__growth__policy_aef14e2429e8bf134e8aeb40de6ed9856}} 
void {\bfseries clear} () noexcept
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Grow the hash table by using prime numbers as bucket count. Slower than \mbox{\hyperlink{classtsl_1_1rh_1_1power__of__two__growth__policy}{tsl\+::rh\+::power\+\_\+of\+\_\+two\+\_\+growth\+\_\+policy}} in

general but will probably distribute the values around better in the buckets with a poor hash function.

To allow the compiler to optimize the modulo operation, a lookup table is used with constant primes numbers.

With a switch the code would look like\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{switch}(iprime) \{ \textcolor{comment}{// iprime is the current prime of the hash table}}
\DoxyCodeLine{    \textcolor{keywordflow}{case} 0: hash \% 5ul;}
\DoxyCodeLine{            \textcolor{keywordflow}{break};}
\DoxyCodeLine{    \textcolor{keywordflow}{case} 1: hash \% 17ul;}
\DoxyCodeLine{            \textcolor{keywordflow}{break};}
\DoxyCodeLine{    \textcolor{keywordflow}{case} 2: hash \% 29ul;}
\DoxyCodeLine{            \textcolor{keywordflow}{break};}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}    }
\end{DoxyCode}


Due to the constant variable in the modulo the compiler is able to optimize the operation by a series of multiplications, substractions and shifts.

The \textquotesingle{}hash \% 5\textquotesingle{} could become something like \textquotesingle{}hash -\/ (hash $\ast$ 0x\+C\+C\+C\+C\+C\+C\+CD) $>$$>$ 34) $\ast$ 5\textquotesingle{} in a 64 bits environment. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/dante/\+Documents/\+Projects/grand-\/blue-\/engine/reverie/src/third\+\_\+party/tsl/robin\+\_\+growth\+\_\+policy.\+h\end{DoxyCompactItemize}
