#1 Don't use editor-oriented file formats at runtime. You wouldn't make a website full of Photoshop PSDs, right? Why make a 3D app full of FBXs.

Unfortunately, the only common, open, standardized 3D delivery-oriented format is glTF. That's really a not bad way to go. I hear good things about the library https://github.com/jkuhlmann/cgltf Writing a glTF viewer is an excellent learning project.

But, if you want to roll your own, it's not hard. Basic game binary formats almost always follow the same pattern:

struct MeshFile {
    struct Header {
        // Magic number so you can sanity check that you are actually parsing the binary format you think you are parsing.
        // 4 bytes makes an int, reversed because of little-endian
        uint32_t magicNumber = 'hsem';
        uint16_t majorVersion; // increment on breaking changes.
        uint16_t minorVersion; // increment on non-breaking changes within a major version.
        uint32_t numVertexBuffers;
        uint32_t vertBufferDescOffset; // byte offset from the start of the file.
        uint32_t indexBufferOffset; // assuming only 1 index buffer
        uint32_t indexBufferSize; // assuming 16 bit vs. 32 bit indices is known ahead of time.
    };
    byte pad[];  // pad with zeroes to alignment requirements.
    struct VertexBufferDesc {
        uint32_t attributeMask; // Insert your own vertex description here.
        uint32_t bufferOffset; // Bytes from the start of the file
        uint32_t bufferSize;
        // Basically, it's a good idea to match the parameters to glBufferData.
    }[numVertexBuffers];
    byte pad[];  // pad with zeroes to alignment requirements.
    byte vertexBuffers[numVertexBuffers][variable bufferSize for each buffer];
    byte pad[];  // pad with zeroes to alignment requirements.
    byte indexBuffer[indexBufferSize];
    uint32_t checksum; // crc of the file up to here so you can check for file errors.
};

fread() the whole file into memory. Use the offsets to find the variably placed chunks. Pass them to GL.

If you want to get fancy, use LZ4 and decompress to memory.

Even fancier: look into persistent mapped buffers, decompress just the headers into malloc'd RAM but decompress the GL data straight into the mapped buffers. Use glCopyBufferSubData to move from the mapped buffer to regular buffers in GPU RAM. This skips over the copy to your own mem; which would have just been copied to a mapped buffer internal to GL.

 Final fancy: Decompress from read-only memory mapped files straight into persistent mapped buffers. Not that hard to set up and pretty hard to beat. Do it in a background thread and you are pretty much final boss.
