///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Includes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "GbTransformComponents.h"

// Standard Includes

// External

// Project
#include "GbTransform.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Namespace Definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace Gb {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Using definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Implementations
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Abstract transform
AbstractTransformComponent::AbstractTransformComponent(TransformComponentType type):
    m_transform(nullptr),
    m_type(type)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AbstractTransformComponent::setTransform(Transform* transform)
{
    m_transform = transform;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Affine component
AffineComponent::AffineComponent(TransformComponentType type):
    AbstractTransformComponent(type)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AffineComponent::computeTransformMatrix(bool updateTransform)
{
    if (m_transform && updateTransform) {
        m_transform->computeWorldMatrix();
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Scale component
ScaleComponent::ScaleComponent():
    AffineComponent(kScaleComponent),
    m_scale(1, 1, 1)
{
    //AffineComponent::computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent::ScaleComponent(const Gb::Matrix4x4f & scaling):
    AffineComponent(kScaleComponent)
{
    m_transformMatrix = scaling;
    AffineComponent::computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent::ScaleComponent(const Gb::Vector3 & scaling):
    AffineComponent(kScaleComponent),
    m_scale(scaling)
{
    computeTransformMatrix();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(double x, double y, double z, bool updateTransform)
{
    m_scale = { float(x), float(y), float(z) };
    computeTransformMatrix(updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(const Gb::Vector3 & scaling, bool updateTransform)
{
    m_scale = scaling;
    computeTransformMatrix(updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(double scaling, bool updateTransform)
{
    m_scale = Gb::Vector3(1, 1, 1) * scaling;
    computeTransformMatrix(updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue ScaleComponent::asJson() const
{
    QJsonObject object = AffineComponent::asJson().toObject();
    object.insert("scaling", m_scale.asJson());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::loadFromJson(const QJsonValue & json)
{
    const QJsonObject & object = json.toObject();
    Vector3 scaling(object.value("scaling"));
    setScale(scaling);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::computeTransformMatrix(bool updateTransform)
{
    m_transformMatrix.setToIdentity();
    m_transformMatrix.addScale(m_scale.asFloat());

    AffineComponent::computeTransformMatrix(updateTransform);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent() :
    AffineComponent(kRotationComponent),
    m_quaternion(Quaternion(0, 0, 0, 1))
{
    //computeTransformMatrix();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent(const Gb::Quaternion & quaternion) :
    AffineComponent(kRotationComponent),
    m_quaternion(quaternion)
{
    computeTransformMatrix();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent(const EulerAngles & eulerAngles):
    AffineComponent(kRotationComponent)
{
    computeTransformMatrix(eulerAngles);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::~RotationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::addRotation(const EulerAngles & eulerAngles, bool updateTransform)
{
    Matrix4x4f addedRotation = eulerAngles.toRotationMatrix();
    m_transformMatrix = addedRotation * m_transformMatrix;
    m_quaternion = Quaternion::fromRotationMatrix(m_transformMatrix);
    if(updateTransform) AffineComponent::computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::setRotation(const Quaternion & quaternion, bool updateTransform)
{
    m_quaternion = quaternion;
    computeTransformMatrix(updateTransform);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::setRotation(const EulerAngles & eulerAngles, bool updateTransform)
{
    if (updateTransform) computeTransformMatrix(eulerAngles);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue RotationComponent::asJson() const
{
    QJsonObject object = AffineComponent::asJson().toObject();
    object.insert("quaternion", m_quaternion.asJson());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::loadFromJson(const QJsonValue & json)
{
    setRotation(Quaternion(json.toObject()["quaternion"]));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::computeTransformMatrix(bool updateTransform)
{
    m_transformMatrix = m_quaternion.toRotationMatrix4x4();
    AffineComponent::computeTransformMatrix(updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::computeTransformMatrix(const EulerAngles & eulerAngles, bool updateTransform)
{
    m_transformMatrix = eulerAngles.toRotationMatrix();
    setRotation(Quaternion::fromRotationMatrix(m_transformMatrix));
    AffineComponent::computeTransformMatrix(updateTransform);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Translation 
Translation::Translation():
    //m_frame(kGLWorld),
    m_position(0, 0, 0)
    //m_velocity(0, 0, 0),
    //m_acceleration(0, 0, 0)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const QJsonValue & json)
{
    loadFromJson(json);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const Vector3 & position, CoordinateFrame frame ):
    m_position(position)
    //m_frame(frame)
{
    Q_UNUSED(frame);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const Vector3 & position, const Vector3 & velocity, const Vector3 & acceleration, CoordinateFrame frame):
    m_position(position)
    //m_velocity(velocity),
    //m_acceleration(acceleration),
    //m_frame(frame)
{
    Q_UNUSED(frame);
    Q_UNUSED(velocity);
    Q_UNUSED(acceleration);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const Translation & t):
    m_position(t.m_position)
    //m_velocity(t.m_velocity),
    //m_acceleration(t.m_acceleration),
    //m_frame(t.m_frame)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::~Translation()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator+(const Translation & t) const
{
    //if (m_frame != t.m_frame) throw("Error, coordinate frames must match");
    //return Translation(m_position + t.m_position,
    //    m_velocity + t.m_velocity,
    //    m_acceleration + t.m_acceleration,
    //    m_frame);
    return Translation(m_position + t.m_position);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator-(const Translation & t) const
{
    //if (m_frame != t.m_frame) throw("Error, coordinate frames must match");
    //return Translation(m_position - t.m_position, 
    //    m_velocity - t.m_velocity, 
    //    m_acceleration - t.m_acceleration, 
    //    m_frame);
    return Translation(m_position - t.m_position);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator*(double c) const
{
    return Translation(std::move(m_position * c));
    //return Translation(m_position * c, m_velocity * c, m_acceleration * c);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator/(double c) const
{
    return Translation(std::move(m_position / c));
    //return Translation(m_position / c, m_velocity / c, m_acceleration / c);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue Translation::asJson() const
{
    QJsonObject object;
    object.insert("position", m_position.asJson());
    //object.insert("velocity", m_velocity.asJson());
    //object.insert("acceleration", m_acceleration.asJson());
    //object.insert("frame", int(m_frame));
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Translation::loadFromJson(const QJsonValue & json)
{
    const QJsonObject& object = json.toObject();
    m_position = Vector3(object["position"]);
    //m_velocity = Vector3(object["velocity"]);
    //m_acceleration = Vector3(object["acceleration"]);
    //m_frame = CoordinateFrame(object["frame"].toInt());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
std::ostream & operator<<(std::ostream & os, const Translation & t)
{
    return os << "Translation("
        << "position: " << t.m_position
        //<< "velocity: " << t.m_velocity
        //<< "acceleration: " << t.m_acceleration
        << ")";
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Translation component
TranslationComponent::TranslationComponent() :
    AbstractTransformComponent(kTranslationComponent)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent::TranslationComponent(const Vector3 & translation) :
    AbstractTransformComponent(kTranslationComponent)
{
    m_translation = translation;
    //computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent::~TranslationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::addTranslation(const Vector3 & position, bool updateTransform)
{
    m_translation.m_position += position;
    if (m_transform && updateTransform) {
        m_transform->computeWorldMatrix();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setPosition(const Vector3 & p, bool updateTransform)
{
    m_translation.m_position = p;
    if (m_transform && updateTransform) {
        m_transform->computeWorldMatrix();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setTranslation(const Translation & position, bool updateTransform)
{
    m_translation = position;
    if (m_transform && updateTransform) {
        m_transform->computeWorldMatrix();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setTranslation(const Vector3 & position, bool updateTransform)
{
    m_translation.m_position = position;
    if (m_transform && updateTransform) {
        m_transform->computeWorldMatrix();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue TranslationComponent::asJson() const
{
    QJsonObject object;
    object.insert("translation", m_translation.asJson().toObject());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::loadFromJson(const QJsonValue & json)
{
    const QJsonObject& object = json.toObject();
    setTranslation(Translation(object.value("translation")));
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//void TranslationComponent::computeTransformMatrix(bool updateTransform)
//{
//    m_transformMatrix.setTranslation(m_translation.m_position.asFloat());
//
//    AffineComponent::computeTransformMatrix(updateTransform);
//}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // end namespacing
