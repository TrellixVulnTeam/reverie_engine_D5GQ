#include "geppetto/qt/widgets/tree/GSceneTreeWidget.h"

#include <QTreeWidgetItemIterator>

#include "fortress/containers/GColor.h"
#include "fortress/logging/GThreadSafeCout.h"

#include "enums/GSceneObjectBehaviorFlagEnum.h"

#include "geppetto/qt/actions/GActionManager.h"
#include "geppetto/qt/actions/commands/GSceneCommand.h"
#include "geppetto/qt/layer/types/GQtConverter.h"
#include "geppetto/qt/style/GFontIcon.h"
#include "geppetto/qt/widgets/GWidgetManager.h"
#include "geppetto/qt/widgets/list/GBlueprintView.h"


namespace rev {

SceneRelatedItem::SceneRelatedItem(SceneType type, const json& j, Uint32_t id):
    TreeItem(id, (int)type, j)
{
    initializeItem();
}


QVariant SceneRelatedItem::mimeData(int role) const
{
    QVariant outData;
    if (role == Qt::UserRole) {
        // Id
        outData = QConverter::ToQt(Uuid(m_data.m_id));
    }
    else if(role == Qt::UserRole + 1){
        // Type
        switch (sceneType()) {
        case SceneRelatedItem::kSceneObject:
            outData = (int)BlueprintModelDragTypes::kSceneObject;
            break;
        default:
            outData = -1;
            break;
        }
    }
    return outData;
}

void SceneRelatedItem::reparent(SceneRelatedItem * newParent, int index)
{
    // Assert type
#ifdef DEBUG_MODE
    if (sceneType() != SceneRelatedItem::kSceneObject) {
        assert(false && "Error, only scene objects may be reparented");
    }
#endif

    // Set encapsulated object's parent
    Int32_t prevParentId = parent() ? static_cast<SceneRelatedItem*>(parent())->m_data.m_id : -1;
    switch (newParent->sceneType()) {
    case SceneRelatedItem::kSceneObject: {
        auto* action = new ReparentSceneObjectCommand(
            sceneTreeWidget()->m_widgetManager,
            m_data.m_id, // Scene object ID
            prevParentId,
            newParent->m_data.m_id,
            index);
        action->perform();
        break;
    }
    default:
        assert(false && "Error, scenario and scene cannot be reparented");
        break;
    }
}

void SceneRelatedItem::performAction(UndoCommand * command)
{
    // Add command to action manager
    sceneTreeWidget()->m_widgetManager->actionManager()->performAction(command);
}

void SceneRelatedItem::setWidget()
{
#ifdef DEBUG_MODE
    if (m_widget) {
        assert(false && "Error, item already has a widget");
    }
#endif

    SceneTreeWidget * parentWidget = static_cast<SceneTreeWidget*>(treeWidget());

    // Set Widget
    QString name;
    switch (sceneType()) {
    case kScenario:
        break;
    case kSceneObject:
    case kScene:
    {
        // Create widget
        name = QString(m_data.getRef<std::string>("name").c_str());
        m_widget = new QLineEdit(name);
        m_widget->setFocusPolicy(Qt::StrongFocus);
        //m_widget->show();

        // Set signal for widget value change
        QObject::connect(static_cast<QLineEdit*>(m_widget),
            &QLineEdit::editingFinished,
            static_cast<QLineEdit*>(m_widget),
            [this]() {
            if (!m_widget) { return; }

            SceneTreeWidget * parentWidget = static_cast<SceneTreeWidget*>(treeWidget());
            QString prevName = m_data.getRef<std::string>("name").c_str();
            QString newName = static_cast<QLineEdit*>(m_widget)->text();
            if (newName.isEmpty()) {
                newName = prevName;
            }

            performAction(new rev::ChangeNameCommand(parentWidget->m_widgetManager, newName.toStdString(), prevName.toStdString(), sceneType()));

        }
        );

        // Set signal for widget out of focus
        QObject::connect(treeWidget(),
            &QTreeWidget::itemSelectionChanged,
            m_widget,
            [this]() {
            if (m_widget) {
                removeWidget(1);
            }
        }
        );

        break;
    }
    default:
        assert(false && "Error, type of item is not implemented");
        break;
    }

    if (m_widget) {
        // Assign widget to item in tree widget
        parentWidget->setItemWidget(this, parentWidget->m_numColumns - 1, m_widget);
    }
}

SceneTreeWidget * SceneRelatedItem::sceneTreeWidget() const
{
    return static_cast<SceneTreeWidget*>(treeWidget());
}


void SceneRelatedItem::initializeItem()
{
    // Set column text
    refreshText();

    // Set flags
    if (sceneType() != kScenario) {
        setFlags(flags() | (Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled));
    }

    if (sceneType() == kSceneObject) {
        // Is scene object, set background color if auto-generated
        if (isAutoGenerated()) {
            setBackground(0, QBrush(QConverter::ToQt(Color(205, 125, 146))));
        }
    }
}

void SceneRelatedItem::refreshText()
{
    switch (sceneType()) {
    case kScenario:
        setText(0, "Scenario");
        break;
    case kScene:
        setIcon(0, SAIcon("box-open"));
        break;
    case kSceneObject:
        setIcon(0, SAIcon("box"));
        break;
    default:
        assert(false && "Error, this item type is not implemented");
        break;
    }

    const std::string& name = m_data.getRef<std::string>("name");
    setText(1, name.c_str());
}


bool SceneRelatedItem::isAutoGenerated() const
{
    ESceneObjectBehaviorFlags soFlags = m_data.get<Uint32_t>("soFlags");
    return soFlags.testFlag(ESceneObjectBehaviorFlag::eScriptGenerated);
}



// SceneTreeWidget


SceneTreeWidget::SceneTreeWidget(WidgetManager* widgetManager, ActionManager* actionManager, const QString & name, QWidget * parent) :
    TreeWidget(widgetManager, actionManager, name, parent, 2),
    m_currentSceneItem(nullptr),
    m_currentSceneObjectItem(nullptr),
    m_lastLeftClickedItem(nullptr)
{
    initializeWidget();
}

SceneTreeWidget::~SceneTreeWidget()
{
}


Int32_t SceneTreeWidget::getCurrentSceneId()
{
    if (m_currentSceneItem) {
        return m_currentSceneItem->m_data.m_id;
    }
    else {
        return -1;
    }
}

Int32_t SceneTreeWidget::getCurrentSceneObjectId()
{
    if (m_currentSceneObjectItem) {
        return m_currentSceneObjectItem->m_data.m_id;
    }
    else {
        return -1;
    }
}

void SceneTreeWidget::setScenarioTreeItem(const json& scenarioJson)
{
    auto* scenarioItem = new SceneRelatedItem(SceneRelatedItem::kScenario, scenarioJson, 0);

    // Clear the widget
    clear();

    // Set header item and disable scene object dragging
    setHeaderItem(scenarioItem);
    invisibleRootItem()->setFlags(invisibleRootItem()->flags() ^ Qt::ItemIsDropEnabled);
    resizeColumns();

    // Set debug items
    const json& debugSceneJson = scenarioItem->m_data.m_data.m_json["debug"]["debugScene"];
    if (!debugSceneJson.empty()) {
        /// @todo This is apparently not guaranteed to be non-empty, so maybe fix this
        addSceneTreeItem(debugSceneJson);
    }

    // Set scene tree items
    const json& sceneJson = scenarioItem->m_data.m_data.m_json["scene"];
    addSceneTreeItem(sceneJson);

}

SceneRelatedItem* SceneTreeWidget::scenarioTreeItem() const
{
    return static_cast<SceneRelatedItem*>(headerItem());
}

void SceneTreeWidget::addSceneTreeItem(const json& j, int index)
{
    // Create scene item
    auto* sceneItem = new SceneRelatedItem(SceneRelatedItem::kScene, j);

    // Add scene item to widget
    if (sceneItem->sceneType() != SceneRelatedItem::kScene) {
        assert(false && "Error, added item is not a scene");
    }

    // Insert scene item into widget
    //insertTopLevelItem(0, sceneItem);
    addItem(sceneItem);

    // Insert top-level scene objects from scene into widget
    /// @todo Script-generated scene objects will not render since they are not saved to JSON
    /// @see https://json.nlohmann.me/api/basic_json/items/
    const json& sceneJson = sceneItem->m_data.m_data.m_json;
    const json& objectsJson = sceneJson["sceneObjects"];
    for (const auto& [key, valJson] : objectsJson.items()) // Key is index as a string, since this is an array
    {
        addSceneObjectTreeItem(valJson);
    }
}

void SceneTreeWidget::removeSceneTreeItem(SceneRelatedItem::SceneType type, const GString& name)
{
    SceneRelatedItem* item = getItem(type, name);
    if (item) {
        removeItem(item);
    }
}

void SceneTreeWidget::removeSceneObjectTreeItem(SceneRelatedItem::SceneType type, Int32_t id)
{
    SceneRelatedItem* item = getSceneObjectItem(id);
    if (item) {
        removeItem(item);
    }
}



void SceneTreeWidget::addSceneObjectTreeItem(const json& j, Int32_t parentId, int index)
{
    // Get parent item
    SceneRelatedItem* parentItem;
    if (parentId > -1) {
        parentItem = getSceneObjectItem(parentId);
    }
    else {
        parentItem = getItem(SceneRelatedItem::kScene, j["scene"].get_ref<const std::string&>());
    }

    // Create scene object item
    Uint32_t sceneObjectId = j["id"].get<Int32_t>();
    auto* sceneObjectItem = new SceneRelatedItem(SceneRelatedItem::kSceneObject, j, sceneObjectId);

    // Add scene object item to parent
    if (parentItem) {
        // If a parent scene was found
        if (index < 0) {
            parentItem->addChild(sceneObjectItem);
        }
        else {
            parentItem->insertChild(index, sceneObjectItem);
        }
        parentItem->setExpanded(true);

        if (parentItem->parent()) {
            // Resize to fit additional parent levels
            resizeColumns(); 
        }
    }
    else {
        assert(false && "Must have either scene or scene object parent");
    }

    // Add child scene objects
    if (!j["children"].empty()) {
        for (const auto& [indexStr, childJson] : j["children"].items()) {
            // Called recursively
            addSceneObjectTreeItem(childJson, sceneObjectId);
        }
    }
}

SceneRelatedItem * SceneTreeWidget::getItem(SceneRelatedItem::SceneType type, const GString& name)
{
    QTreeWidgetItemIterator it(this);
    while (*it) {
        SceneRelatedItem* item = static_cast<SceneRelatedItem*>(*it);
        if (item->sceneType() != type) {
            ++it;
            continue;
        }

        if (SceneRelatedItem::kScenario == type) {
            return item;
        }
        else if (SceneRelatedItem::kScene == type) {
            // Return non-debug scene if applicable
            bool requestingDebugScene = name.asLower().contains("debug");
            GString sceneName = item->m_data.getRef<const std::string&>("name");
            if (!requestingDebugScene && !sceneName.asLower().contains("debug")) {
                return item;
            }
            else if (requestingDebugScene && sceneName.asLower().contains("debug")) {
                // Return debug scene, which is named "Debug Objects"
                return item;
            }
        }
        else {
            if (name == item->m_data.getRef<const std::string&>("name")) {
                return item;
            }
        }
        ++it;
    }
    return nullptr;
}

SceneRelatedItem * SceneTreeWidget::getSceneObjectItem(Int32_t id)
{
    QTreeWidgetItemIterator it(this);
    while (*it) {
        SceneRelatedItem* item = static_cast<SceneRelatedItem*>(*it);
        if (item->sceneType() != SceneRelatedItem::kSceneObject) {
            ++it;
            continue;
        }
        if (id == item->m_data.get<Uint32_t>("id")) {
            return item;
        }
        ++it;
    }
    return nullptr;
}

void SceneTreeWidget::clearSelectedItems()
{
    clearSelection();
    m_currentSceneItem = nullptr;
    m_currentSceneObjectItem = nullptr;

    m_deselectedSceneObjectSignal.emitForAll();
}

void SceneTreeWidget::removeScenarioTreeItem()
{
    // Delete scenario
    delete headerItem();
    setHeaderItem(nullptr);
    setHeaderLabels(QStringList({""}));

    // Delete scene items from scenario
    clear();

    //resizeColumns();
}

void SceneTreeWidget::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    Q_UNUSED(column)

    // Downcast item
    auto* sceneItem = static_cast<SceneRelatedItem*>(item);
    if (!sceneItem->m_widget) {
        // Set widget if there isn't one cached by scene tree widget
        // TODO: Investigate if TreeWidget will cause a memory leak by caching item widgets
        sceneItem->setWidget();
    }
}

void SceneTreeWidget::onItemClicked(QTreeWidgetItem * item, int column)
{
    Q_UNUSED(column)
    
    // Downcast item
    auto* sceneRelatedItem = static_cast<SceneRelatedItem*>(item);

    if (m_lastLeftClickedItem == sceneRelatedItem) return;

    // Emit signal that last item was deselected
    if(m_lastLeftClickedItem){
        switch (m_lastLeftClickedItem->sceneType()) {
        case SceneRelatedItem::kScene:
            m_deselectedSceneSignal.emitForAll();
            break;
        case SceneRelatedItem::kSceneObject:
            m_deselectedSceneObjectSignal.emitForAll();
            break;
        default:
            break;
        }
    }

    switch (sceneRelatedItem->sceneType()) {
    case SceneRelatedItem::kSceneObject:
    {
        m_lastLeftClickedItem = static_cast<SceneRelatedItem*>(item);
        m_currentSceneObjectItem = m_lastLeftClickedItem;
        Uint32_t sceneObjectId = m_lastLeftClickedItem->m_data.m_id;
        m_selectedSceneObjectSignal.emitForAll(sceneObjectId);
        break;
    }
    case SceneRelatedItem::kScene:
    {
        m_lastLeftClickedItem = static_cast<SceneRelatedItem*>(item);
        m_currentSceneItem = m_lastLeftClickedItem;
        m_currentSceneObjectItem = nullptr;
        //Uuid sceneId = m_lastLeftClickedItem->m_data.get<Uuid>("uuid");
        GString sceneName = m_lastLeftClickedItem->m_data.getRef<const std::string&>("name").c_str();
        m_selectedSceneSignal.emitForAll(sceneName);
        break;
    }
    default:
        break;
    }
}

void SceneTreeWidget::onItemExpanded(QTreeWidgetItem * item)
{
    Q_UNUSED(item)
}

QMimeData * SceneTreeWidget::mimeData(const QList<QTreeWidgetItem*> items) const
{
    QMimeData *mimeData = new QMimeData();
    QByteArray encodedIdData;
    QByteArray encodedTypeData;

    QDataStream idStream(&encodedIdData, QIODevice::WriteOnly);
    QDataStream typeStream(&encodedTypeData, QIODevice::WriteOnly);
    for (QTreeWidgetItem* it : items) {
        SceneRelatedItem* item = dynamic_cast<SceneRelatedItem*>(it);
        //size_t idx = index.row();
        QUuid uuid = item->mimeData(Qt::UserRole).toUuid();
//        QString uuidStr = uuid.toString();
//#ifdef DEBUG_MODE
//        Logger::LogInfo(uuidStr);
//#endif
        idStream << uuid;

        int itemType = item->mimeData(Qt::UserRole + 1).toInt();
        typeStream << itemType; // Type of item
    }

    mimeData->setData("reverie/id/uuid", encodedIdData);
    mimeData->setData("reverie/id/type", encodedTypeData);

    return mimeData;
}

QStringList SceneTreeWidget::mimeTypes() const
{
    QStringList types;
    types << "reverie/id/uuid";
    types << "reverie/id/type";
    return types;
}

void SceneTreeWidget::initializeItem(QTreeWidgetItem * item)
{
    Q_UNUSED(item);
}

void SceneTreeWidget::onDropOn(QDropEvent * event, QTreeWidgetItem * source, QTreeWidgetItem * destination)
{
    // On an item, so add current item as child
    SceneRelatedItem* sourceItem = static_cast<SceneRelatedItem*>(source);
    SceneRelatedItem* destItem = static_cast<SceneRelatedItem*>(destination);

    if (sourceItem->sceneType() == SceneRelatedItem::kSceneObject) {
        // Item being dropped is a scene object
        switch (destItem->sceneType()) {
        case SceneRelatedItem::kScene:
        case SceneRelatedItem::kSceneObject:
            // Fall through to default, handle drop action in reparent()
            sourceItem->reparent(destItem);
        default:
            event->setDropAction(Qt::IgnoreAction);
            break;
        }
    }

    // If not set, Qt will do its own reparenting, which DOESN'T WORK
    event->setDropAction(Qt::IgnoreAction);
}

void SceneTreeWidget::onDropBelow(QDropEvent * event, QTreeWidgetItem * source, QTreeWidgetItem * destination)
{
    // On an item, so add current item as child
    SceneRelatedItem* sourceItem = static_cast<SceneRelatedItem*>(source);
    SceneRelatedItem* destItem = static_cast<SceneRelatedItem*>(destination);
    SceneRelatedItem* parentItem = static_cast<SceneRelatedItem*>(destination->parent());

    if (sourceItem->sceneType() == SceneRelatedItem::kSceneObject) {
        // Item being dropped is a scene object
        // If no parent destination item, set to this source item's parent scene
        int index = -1;
        if (!parentItem) {
            parentItem = getItem(SceneRelatedItem::kScene, sourceItem->m_data.getRef<const std::string&>("scene"));
        }
        else {
            // Get at which to insert new item
            index = parentItem->indexOfChild(destItem);
        }



        // Act based on destination item type
        switch (parentItem->sceneType()) {
        case SceneRelatedItem::kScene:
        case SceneRelatedItem::kSceneObject:
            // Fall through to default, handle drop action in reparent()
            sourceItem->reparent(parentItem, index);
        default:
            event->setDropAction(Qt::IgnoreAction);
            break;
        }
    }

    // If not set, Qt will do its own reparenting, which DOESN'T WORK
    event->setDropAction(Qt::IgnoreAction);
}

void SceneTreeWidget::onDropAbove(QDropEvent * event, QTreeWidgetItem * source, QTreeWidgetItem * destination)
{
    // On an item, so add current item as child
    SceneRelatedItem* sourceItem = static_cast<SceneRelatedItem*>(source);
    SceneRelatedItem* destItem = static_cast<SceneRelatedItem*>(destination);
    SceneRelatedItem* parentItem = static_cast<SceneRelatedItem*>(destination->parent());

    if (sourceItem->sceneType() == SceneRelatedItem::kSceneObject) {
        // Item being dropped is a scene object
        // If no destination item, set to this source item's parent scene
        int index = -1;
        if (!parentItem) {
            parentItem = getItem(SceneRelatedItem::kScene, sourceItem->m_data.getRef<const std::string&>("scene"));
        }
        else {
            // Get at which to insert new item
            index = parentItem->indexOfChild(destItem);
        }

        // Act based on destination item type
        switch (parentItem->sceneType()) {
        case SceneRelatedItem::kScene:
        case SceneRelatedItem::kSceneObject:
            // Fall through to default, handle drop action in reparent()
            sourceItem->reparent(parentItem, index);
        default:
            event->setDropAction(Qt::IgnoreAction);
            break;
        }
    }

    // If not set, Qt will do its own reparenting, which DOESN'T WORK
    event->setDropAction(Qt::IgnoreAction);
}

void SceneTreeWidget::onDropViewport(QDropEvent * event, QTreeWidgetItem * source)
{
    // On viewport, so set as child of scenario's scene
    SceneRelatedItem* sourceItem = static_cast<SceneRelatedItem*>(source);
    if (sourceItem->sceneType() == SceneRelatedItem::kSceneObject) {
        SceneRelatedItem* sceneItem = getItem(SceneRelatedItem::kScene, sourceItem->m_data.getRef<const std::string&>("scene"));
        sourceItem->reparent(sceneItem);
    }

    // If not set, Qt will do its own reparenting, which DOESN'T WORK
    event->setDropAction(Qt::IgnoreAction);
}

void SceneTreeWidget::onDropFromOtherWidget(QDropEvent * event, QTreeWidgetItem * source, QWidget * otherWidget)
{
    //SceneRelatedItem* sourceItem = static_cast<SceneRelatedItem*>(source);
    //SceneRelatedItem* destItem = static_cast<SceneRelatedItem*>(destination);
    ThreadSafeCout{} << "Dropped blueprint";
}

void SceneTreeWidget::removeItem(SceneRelatedItem * sceneItem)
{
    switch (sceneItem->sceneType()) {
    case SceneRelatedItem::kScenario:
    case SceneRelatedItem::kScene:
    case SceneRelatedItem::kSceneObject:
        break;
    default:
        assert(false && "Error, item type is not implemented");
        break;
    }

    delete sceneItem;
}

void SceneTreeWidget::initializeWidget()
{
    TreeWidget::initializeWidget();

    // Set tree widget settings
    setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Expanding);
    setHeaderLabels(QStringList({""}));
    setAlternatingRowColors(true);

    // Set first column width
    //QFontMetrics metrics(FontManager::solidFontAwesomeFamily());
    //setColumnWidth(0, metrics.width("\uf468") * 3);
    setColumnWidth(0, columnWidth(0) * 0.75);
    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Expanding);

    // Enable drag and drop
    enableDragAndDrop();

    // Initialize create scenario action
    m_addScenario = new QAction(tr("&New Scenario"), this);
    m_addScenario->setStatusTip("Create a new scenario");
    connect(m_addScenario, 
        &QAction::triggered, 
        m_widgetManager->actionManager(),
        [this] {
            m_widgetManager->actionManager()->performAction(new AddScenarioCommand(m_widgetManager, "Create New Scenario")); 
        });


    // Initialize create scene object action
    m_addSceneObject = new QAction(tr("&New Scene Object"), this);
    m_addSceneObject->setStatusTip("Create a new scene object");
    connect(m_addSceneObject,
        &QAction::triggered,
        m_widgetManager->actionManager(),
        [this] {
        
        AddSceneObjectCommand* action;
        if (m_currentSceneObjectItem) {
            // There is a scene object selected, so add new object as a child
            action = new AddSceneObjectCommand(m_widgetManager, "Add Child Object", m_currentSceneObjectItem->data().m_id);
        }
        else {
            // There is no scene object selected, so adding object without parent
            action = new AddSceneObjectCommand(m_widgetManager, "Create New Scene Object");
        }

        m_widgetManager->actionManager()->performAction(action);

    });

    // Initialize copy scene object action
    m_copySceneObject = new QAction(tr("&Copy Scene Object"), this);
    m_copySceneObject->setStatusTip("Duplicate the selected scene object");
    connect(m_copySceneObject,
        &QAction::triggered,
        m_widgetManager->actionManager(),
        [this] {

        uint32_t index = m_currentItems[kContextClick]->parent()->indexOfChild(m_currentSceneObjectItem);
        CopySceneObjectCommand* action = new CopySceneObjectCommand(m_widgetManager, m_currentSceneObjectItem->data().m_id, index, "Copy Scene Object");

        m_widgetManager->actionManager()->performAction(action);

    });

    // Initialize remove scene object action
    m_removeSceneObject = new QAction(tr("&Remove Scene Object"), this);
    m_removeSceneObject->setStatusTip("Remove the selected scene object");
    connect(m_removeSceneObject,
        &QAction::triggered,
        m_widgetManager->actionManager(),
        [this] {

        RemoveSceneObjectCommand* action = new RemoveSceneObjectCommand(m_widgetManager, m_currentSceneObjectItem->data().m_id, "Remove Scene Object");
        m_widgetManager->actionManager()->performAction(action);

    });

    // Populate on scenario load
    connect(m_widgetManager,
        &WidgetManager::receivedScenarioJsonMessage,
        this,
        [this]() {
            setScenarioTreeItem(m_widgetManager->scenarioJson());
        });

    // Connect signal for double click events
    connect(this, &SceneTreeWidget::itemDoubleClicked,
        this, &SceneTreeWidget::onItemDoubleClicked);

    // Connect signal for click events
    connect(this, &SceneTreeWidget::itemClicked,
        this, &SceneTreeWidget::onItemClicked);

    // Connect signal for item expansion
    connect(this, &SceneTreeWidget::itemExpanded,
        this, &SceneTreeWidget::onItemExpanded);
}

bool SceneTreeWidget::dropMimeData(QTreeWidgetItem *parent, int index, const QMimeData *data, Qt::DropAction action)
{
    bool success = true;
    if (!data->hasFormat("reverie/id/uuid")) {
        success = QTreeWidget::dropMimeData(parent, index, data, action);
        return success;
    }

    // Handling drops from other widgets
    QByteArray encodedIdData = data->data("reverie/id/uuid");
    QByteArray encodedTypeData = data->data("reverie/id/type");
    QDataStream stream(&encodedIdData, QIODevice::ReadOnly);
    QDataStream typeStream(&encodedTypeData, QIODevice::ReadOnly);
    QUuid itemQId;
    int itemType = -1;
    while (!stream.atEnd()) {
        // Should only do this once, but using this since reinterpret_cast with encoded data can be a mess
        stream >> itemQId;
    }
    while (!typeStream.atEnd()) {
        // Won't be reached if no type
        typeStream >> itemType;
    }
    Uuid itemId = itemQId.toString().toStdString();

    // Only blueprints are valid for drop right now
    const json& blueprints = scenarioTreeItem()->m_data.m_data.m_json["blueprints"];

    auto iter = std::find_if(blueprints.begin(), blueprints.end(),
        [&itemId](const json& bp) {
            Uuid id;
            from_json(bp["uuid"], id);
            return id == itemId; }
    );
    if (iter == blueprints.end()) {
        assert(false && "Error, blueprint not found");
    }
    const json& bp = *iter;

    // Create scene object from blueprint
    SceneRelatedItem* sceneItem = dynamic_cast<SceneRelatedItem*>(parent);
    if (sceneItem) {

        // Identify parent
        Int32_t parentId = -1;
        if (SceneRelatedItem::kSceneObject == sceneItem->sceneType()) {
            parentId = sceneItem->m_data.m_id;
        }

        // Create scene object
        const json& soJson = bp["so"];
        AddSceneObjectCommand* action = new AddSceneObjectCommand(
            m_widgetManager,
            "Instantiate blueprint",
            -1); // No parent, just add to scene

        m_widgetManager->actionManager()->performAction(action);

        //emit m_engine->scenarioChanged(); // No longer needed hopefully
    }

    return success;
}


#ifndef QT_NO_CONTEXTMENU
void SceneTreeWidget::contextMenuEvent(QContextMenuEvent *event)
{
    // Create menu
    QMenu menu(this);

    // Add actions to the menu
    auto* item = static_cast<SceneRelatedItem*>(itemAt(event->pos()));
    if (item) {
        m_currentItems[kContextClick] = item;

        switch (item->sceneType()) {
        case SceneRelatedItem::kScene: {
            m_currentSceneObjectItem = nullptr;
            m_currentSceneItem = item;
            const std::string& sceneName = m_currentSceneItem->m_data.getRef<const std::string&>("name");
            if (sceneName != "Debug Objects") {
                menu.addAction(m_addSceneObject);
            }
            break;
        }
        case SceneRelatedItem::kSceneObject:
        {
            m_currentSceneObjectItem = item;
            const std::string& sceneName = m_currentSceneObjectItem->m_data.getRef<const std::string&>("scene");
            m_currentSceneItem = getItem(SceneRelatedItem::kScene, sceneName);
            menu.addAction(m_addSceneObject);
            menu.addAction(m_copySceneObject);
            menu.addAction(m_removeSceneObject);
                
            // Disable action if scene object is python generated
            menu.actions().back()->setDisabled(m_currentSceneItem->isAutoGenerated());

            break;
        }
        default:
            break;
        }
    }
    else {
        m_currentItems[kContextClick] = nullptr;

        // Enable options to add things when there is no item selected, if not in debug scene
        if (m_currentSceneItem) {
            const std::string& sceneName = m_currentSceneItem->m_data.getRef<const std::string&>("name");

            if (sceneName != "Debug Objects") {
                menu.addAction(m_addSceneObject);
                menu.addSeparator();
            }
        }
        menu.addAction(m_addScenario);
    }

    // Display menu at click location
    menu.exec(event->globalPos());
}

#endif // QT_NO_CONTEXTMENU


} // rev