<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Reverie: tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Reverie
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1ordered__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a02fb4e2e15f314f6ac35c214d9df23ef"><td class="memItemLeft" align="right" valign="top"><a id="a02fb4e2e15f314f6ac35c214d9df23ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = typename ht::key_type</td></tr>
<tr class="separator:a02fb4e2e15f314f6ac35c214d9df23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3852aebb63dcde9d151859cb65f951e"><td class="memItemLeft" align="right" valign="top"><a id="aa3852aebb63dcde9d151859cb65f951e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename ht::value_type</td></tr>
<tr class="separator:aa3852aebb63dcde9d151859cb65f951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2679e2e7b1ac5583afe30254f3fe2391"><td class="memItemLeft" align="right" valign="top"><a id="a2679e2e7b1ac5583afe30254f3fe2391"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename ht::size_type</td></tr>
<tr class="separator:a2679e2e7b1ac5583afe30254f3fe2391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aabf02f8feedcae29dc7486d764a9b"><td class="memItemLeft" align="right" valign="top"><a id="a74aabf02f8feedcae29dc7486d764a9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = typename ht::difference_type</td></tr>
<tr class="separator:a74aabf02f8feedcae29dc7486d764a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223d8468abce9948f98b3b95d1e982c"><td class="memItemLeft" align="right" valign="top"><a id="a5223d8468abce9948f98b3b95d1e982c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = typename ht::hasher</td></tr>
<tr class="separator:a5223d8468abce9948f98b3b95d1e982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c68662e5e311f48f70ace69759342f"><td class="memItemLeft" align="right" valign="top"><a id="a13c68662e5e311f48f70ace69759342f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = typename ht::key_equal</td></tr>
<tr class="separator:a13c68662e5e311f48f70ace69759342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbfaf193b1d445d0947dfc5678b6855"><td class="memItemLeft" align="right" valign="top"><a id="a8fbfaf193b1d445d0947dfc5678b6855"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = typename ht::allocator_type</td></tr>
<tr class="separator:a8fbfaf193b1d445d0947dfc5678b6855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958a0120052bda326fb7bf72e9878a5c"><td class="memItemLeft" align="right" valign="top"><a id="a958a0120052bda326fb7bf72e9878a5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = typename ht::reference</td></tr>
<tr class="separator:a958a0120052bda326fb7bf72e9878a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213465f357963c30b084451ad61299ac"><td class="memItemLeft" align="right" valign="top"><a id="a213465f357963c30b084451ad61299ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = typename ht::const_reference</td></tr>
<tr class="separator:a213465f357963c30b084451ad61299ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274eb7795de5ce31fa932e97ccb255cb"><td class="memItemLeft" align="right" valign="top"><a id="a274eb7795de5ce31fa932e97ccb255cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename ht::pointer</td></tr>
<tr class="separator:a274eb7795de5ce31fa932e97ccb255cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd3a5ea8376cdc30c81eb93283b352b"><td class="memItemLeft" align="right" valign="top"><a id="a3bd3a5ea8376cdc30c81eb93283b352b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = typename ht::const_pointer</td></tr>
<tr class="separator:a3bd3a5ea8376cdc30c81eb93283b352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b02aa2270e720edf5b8a30b106e7346"><td class="memItemLeft" align="right" valign="top"><a id="a6b02aa2270e720edf5b8a30b106e7346"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = typename ht::iterator</td></tr>
<tr class="separator:a6b02aa2270e720edf5b8a30b106e7346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1996923ed0d9b62d7d959af57a1be3"><td class="memItemLeft" align="right" valign="top"><a id="a3a1996923ed0d9b62d7d959af57a1be3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename ht::const_iterator</td></tr>
<tr class="separator:a3a1996923ed0d9b62d7d959af57a1be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850e708a94572268b80d79d8238c74fd"><td class="memItemLeft" align="right" valign="top"><a id="a850e708a94572268b80d79d8238c74fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = typename ht::reverse_iterator</td></tr>
<tr class="separator:a850e708a94572268b80d79d8238c74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cdc912734a2b6757cbb816ab2657ea"><td class="memItemLeft" align="right" valign="top"><a id="ac4cdc912734a2b6757cbb816ab2657ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = typename ht::const_reverse_iterator</td></tr>
<tr class="separator:ac4cdc912734a2b6757cbb816ab2657ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68942b7edb65da7c0ec756b7172f497"><td class="memItemLeft" align="right" valign="top"><a id="af68942b7edb65da7c0ec756b7172f497"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>values_container_type</b> = typename ht::values_container_type</td></tr>
<tr class="separator:af68942b7edb65da7c0ec756b7172f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"><td class="memItemLeft" align="right" valign="top"><a id="a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (size_type bucket_count, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c776d606ff253b16ded3ebc50f081"><td class="memItemLeft" align="right" valign="top"><a id="a0a2c776d606ff253b16ded3ebc50f081"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (size_type bucket_count, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a0a2c776d606ff253b16ded3ebc50f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684dbea1303cf3173ea839eee34fd44"><td class="memItemLeft" align="right" valign="top"><a id="ab684dbea1303cf3173ea839eee34fd44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ab684dbea1303cf3173ea839eee34fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a7fcbb629b9c000c2e77925b4fa36"><td class="memItemLeft" align="right" valign="top"><a id="a721a7fcbb629b9c000c2e77925b4fa36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a721a7fcbb629b9c000c2e77925b4fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad057518e7311f0437ec1f7b059525bd"><td class="memTemplParams" colspan="2"><a id="aad057518e7311f0437ec1f7b059525bd"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:aad057518e7311f0437ec1f7b059525bd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordered_set</b> (InputIt first, InputIt last, size_type bucket_count=ht::DEFAULT_INIT_BUCKETS_SIZE, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:aad057518e7311f0437ec1f7b059525bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1925811490371805e060c1488063a545"><td class="memTemplParams" colspan="2"><a id="a1925811490371805e060c1488063a545"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a1925811490371805e060c1488063a545"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordered_set</b> (InputIt first, InputIt last, size_type bucket_count, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a1925811490371805e060c1488063a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a736e5534ba4a3c0467779df0b26b"><td class="memTemplParams" colspan="2"><a id="a040a736e5534ba4a3c0467779df0b26b"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a040a736e5534ba4a3c0467779df0b26b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordered_set</b> (InputIt first, InputIt last, size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a040a736e5534ba4a3c0467779df0b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15847bafa2827f9558ff3113ce3c047"><td class="memItemLeft" align="right" valign="top"><a id="af15847bafa2827f9558ff3113ce3c047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (std::initializer_list&lt; value_type &gt; init, size_type bucket_count=ht::DEFAULT_INIT_BUCKETS_SIZE, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:af15847bafa2827f9558ff3113ce3c047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756674af513e07365ea58a4307ea068"><td class="memItemLeft" align="right" valign="top"><a id="a3756674af513e07365ea58a4307ea068"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (std::initializer_list&lt; value_type &gt; init, size_type bucket_count, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a3756674af513e07365ea58a4307ea068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada7c8348ee664b0c8d51c241ce3c82"><td class="memItemLeft" align="right" valign="top"><a id="a4ada7c8348ee664b0c8d51c241ce3c82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_set</b> (std::initializer_list&lt; value_type &gt; init, size_type bucket_count, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a4ada7c8348ee664b0c8d51c241ce3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e545a2e1c9252da9aafd3b8d9027996"><td class="memItemLeft" align="right" valign="top"><a id="a4e545a2e1c9252da9aafd3b8d9027996"></a>
<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::initializer_list&lt; value_type &gt; ilist)</td></tr>
<tr class="separator:a4e545a2e1c9252da9aafd3b8d9027996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee92e0575ea5eda52000fa7359e19a"><td class="memItemLeft" align="right" valign="top"><a id="a43ee92e0575ea5eda52000fa7359e19a"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a43ee92e0575ea5eda52000fa7359e19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13854981a0a6dcf3caa8681249c8a2a6"><td class="memItemLeft" align="right" valign="top"><a id="a13854981a0a6dcf3caa8681249c8a2a6"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:a13854981a0a6dcf3caa8681249c8a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc4e4dd0290e5e95ac5581a90877d7"><td class="memItemLeft" align="right" valign="top"><a id="a8bcc4e4dd0290e5e95ac5581a90877d7"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a8bcc4e4dd0290e5e95ac5581a90877d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10355d72c3d4c1ab5c3995612239f40f"><td class="memItemLeft" align="right" valign="top"><a id="a10355d72c3d4c1ab5c3995612239f40f"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a10355d72c3d4c1ab5c3995612239f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa697b0fafb7028551f4d4f66381ca8"><td class="memItemLeft" align="right" valign="top"><a id="a5aa697b0fafb7028551f4d4f66381ca8"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a5aa697b0fafb7028551f4d4f66381ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2eb040a0129c07e9735448b114ab5e8"><td class="memItemLeft" align="right" valign="top"><a id="aa2eb040a0129c07e9735448b114ab5e8"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:aa2eb040a0129c07e9735448b114ab5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54476254fe316471d65ff77a73941fb5"><td class="memItemLeft" align="right" valign="top"><a id="a54476254fe316471d65ff77a73941fb5"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a54476254fe316471d65ff77a73941fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e062f9c1505b58ad17726d9accdfa21"><td class="memItemLeft" align="right" valign="top"><a id="a5e062f9c1505b58ad17726d9accdfa21"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () noexcept</td></tr>
<tr class="separator:a5e062f9c1505b58ad17726d9accdfa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b6e77078a912cfaea9ebc45e876aea"><td class="memItemLeft" align="right" valign="top"><a id="ad2b6e77078a912cfaea9ebc45e876aea"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:ad2b6e77078a912cfaea9ebc45e876aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37e8d6244ab4f608e00b619e14433a5"><td class="memItemLeft" align="right" valign="top"><a id="aa37e8d6244ab4f608e00b619e14433a5"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rcbegin</b> () const noexcept</td></tr>
<tr class="separator:aa37e8d6244ab4f608e00b619e14433a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae499a978d0a0aec34cdc37ade4137aff"><td class="memItemLeft" align="right" valign="top"><a id="ae499a978d0a0aec34cdc37ade4137aff"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () noexcept</td></tr>
<tr class="separator:ae499a978d0a0aec34cdc37ade4137aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d74ddd51e82e4b632057b69935b116"><td class="memItemLeft" align="right" valign="top"><a id="aa0d74ddd51e82e4b632057b69935b116"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:aa0d74ddd51e82e4b632057b69935b116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad2ff2e0a44fc871f8350b44a40e16"><td class="memItemLeft" align="right" valign="top"><a id="a4bad2ff2e0a44fc871f8350b44a40e16"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rcend</b> () const noexcept</td></tr>
<tr class="separator:a4bad2ff2e0a44fc871f8350b44a40e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023ea62fd39e755099542ff6dda50d1e"><td class="memItemLeft" align="right" valign="top"><a id="a023ea62fd39e755099542ff6dda50d1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="separator:a023ea62fd39e755099542ff6dda50d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa37a53d11a5076aaeb33353028f4d7"><td class="memItemLeft" align="right" valign="top"><a id="a1fa37a53d11a5076aaeb33353028f4d7"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="separator:a1fa37a53d11a5076aaeb33353028f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a7b4a8594e064e79b47fc6a502f436"><td class="memItemLeft" align="right" valign="top"><a id="a32a7b4a8594e064e79b47fc6a502f436"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const noexcept</td></tr>
<tr class="separator:a32a7b4a8594e064e79b47fc6a502f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec08c6e8d45c108e5690bfffe12cd5"><td class="memItemLeft" align="right" valign="top"><a id="acbec08c6e8d45c108e5690bfffe12cd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="separator:acbec08c6e8d45c108e5690bfffe12cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a20c731b0e04d44d494c5f43ef8de"><td class="memItemLeft" align="right" valign="top"><a id="a328a20c731b0e04d44d494c5f43ef8de"></a>
std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const value_type &amp;value)</td></tr>
<tr class="separator:a328a20c731b0e04d44d494c5f43ef8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b6e9cf63b58ec83966f5d97661583d"><td class="memItemLeft" align="right" valign="top"><a id="aa7b6e9cf63b58ec83966f5d97661583d"></a>
std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:aa7b6e9cf63b58ec83966f5d97661583d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2459ce77751afca0043efcce1eb09cd5"><td class="memItemLeft" align="right" valign="top"><a id="a2459ce77751afca0043efcce1eb09cd5"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr class="separator:a2459ce77751afca0043efcce1eb09cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbba255e05528bca39a13ae86b5035c6"><td class="memItemLeft" align="right" valign="top"><a id="abbba255e05528bca39a13ae86b5035c6"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const_iterator hint, value_type &amp;&amp;value)</td></tr>
<tr class="separator:abbba255e05528bca39a13ae86b5035c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621d330cbf43fec798bc63d191ed034"><td class="memTemplParams" colspan="2"><a id="a9621d330cbf43fec798bc63d191ed034"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9621d330cbf43fec798bc63d191ed034"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a9621d330cbf43fec798bc63d191ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206421a6a18589f4bd7562c2db43d910"><td class="memItemLeft" align="right" valign="top"><a id="a206421a6a18589f4bd7562c2db43d910"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; value_type &gt; ilist)</td></tr>
<tr class="separator:a206421a6a18589f4bd7562c2db43d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad4a8ee2e57f3c30fe19b326a874f0bd5">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266d5e2425b6af842790944fa75ef76"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad266d5e2425b6af842790944fa75ef76"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad266d5e2425b6af842790944fa75ef76">emplace_hint</a> (const_iterator hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad266d5e2425b6af842790944fa75ef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb7fc84c0bfab1c196109d416bad85"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a91cb7fc84c0bfab1c196109d416bad85">erase</a> (iterator pos)</td></tr>
<tr class="separator:a91cb7fc84c0bfab1c196109d416bad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3e96aba2834dcc28b22ee8699c914"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a05c3e96aba2834dcc28b22ee8699c914">erase</a> (const_iterator pos)</td></tr>
<tr class="separator:a05c3e96aba2834dcc28b22ee8699c914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c0fb661e5e389f82bcb9f157db45d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a318c0fb661e5e389f82bcb9f157db45d">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="separator:a318c0fb661e5e389f82bcb9f157db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1e1054dd9e86fc0617070ad35f8d45"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4a1e1054dd9e86fc0617070ad35f8d45">erase</a> (const key_type &amp;key)</td></tr>
<tr class="separator:a4a1e1054dd9e86fc0617070ad35f8d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35895b2267b33386efdc0ccf2b262154"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a35895b2267b33386efdc0ccf2b262154">erase</a> (const key_type &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a35895b2267b33386efdc0ccf2b262154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc0464c0f492f1b411fcef7ac396936"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aabc0464c0f492f1b411fcef7ac396936"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aabc0464c0f492f1b411fcef7ac396936">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:aabc0464c0f492f1b411fcef7ac396936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0e6377f984cd852e8861174fc28786"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e0e6377f984cd852e8861174fc28786"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7e0e6377f984cd852e8861174fc28786">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a7e0e6377f984cd852e8861174fc28786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2982b9af31dc0cfc8a9eccd9fe325fc"><td class="memItemLeft" align="right" valign="top"><a id="ac2982b9af31dc0cfc8a9eccd9fe325fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;other)</td></tr>
<tr class="separator:ac2982b9af31dc0cfc8a9eccd9fe325fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ec8f539f3a0dc869bd024bde891c8a"><td class="memItemLeft" align="right" valign="top"><a id="aa5ec8f539f3a0dc869bd024bde891c8a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>count</b> (const Key &amp;key) const</td></tr>
<tr class="separator:aa5ec8f539f3a0dc869bd024bde891c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6671d647ef9402361c009af2f47e29ba"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6671d647ef9402361c009af2f47e29ba">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a6671d647ef9402361c009af2f47e29ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a766cac50caed1afe6b1dbb2c6447a55b">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced79117d7534ed3ab2d6a237a0058bc"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aced79117d7534ed3ab2d6a237a0058bc"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aced79117d7534ed3ab2d6a237a0058bc">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aced79117d7534ed3ab2d6a237a0058bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1bbc404cc363153b6eb7d505448427"><td class="memItemLeft" align="right" valign="top"><a id="aaa1bbc404cc363153b6eb7d505448427"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const Key &amp;key)</td></tr>
<tr class="separator:aaa1bbc404cc363153b6eb7d505448427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe63aacec0b31672f70753f20c7e0d8b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abe63aacec0b31672f70753f20c7e0d8b">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:abe63aacec0b31672f70753f20c7e0d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49dd84b051493b6847f5ef7c7083d2b"><td class="memItemLeft" align="right" valign="top"><a id="ab49dd84b051493b6847f5ef7c7083d2b"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const Key &amp;key) const</td></tr>
<tr class="separator:ab49dd84b051493b6847f5ef7c7083d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef6331a007f7a8848b5dabc89238946"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aaef6331a007f7a8848b5dabc89238946">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aaef6331a007f7a8848b5dabc89238946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c6728c8839d9bfcec8785a3a918d33"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a46c6728c8839d9bfcec8785a3a918d33"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a46c6728c8839d9bfcec8785a3a918d33">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a46c6728c8839d9bfcec8785a3a918d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aced9be09be40ecc1b2b53148fdbeae3c">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f4eb260419db865a600bb927fde308"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a32f4eb260419db865a600bb927fde308"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a32f4eb260419db865a600bb927fde308">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a32f4eb260419db865a600bb927fde308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b56494c36c62b257971a5c89ce43ace"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9b56494c36c62b257971a5c89ce43ace"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a9b56494c36c62b257971a5c89ce43ace">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a9b56494c36c62b257971a5c89ce43ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f3c4a9c769412558086ce4b9646f79"><td class="memItemLeft" align="right" valign="top"><a id="a75f3c4a9c769412558086ce4b9646f79"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const Key &amp;key) const</td></tr>
<tr class="separator:a75f3c4a9c769412558086ce4b9646f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95347e23841cb607b1fe291da16a045a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a95347e23841cb607b1fe291da16a045a">contains</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a95347e23841cb607b1fe291da16a045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f5653e37108274b91d34666a9ef7a9"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a90f5653e37108274b91d34666a9ef7a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a90f5653e37108274b91d34666a9ef7a9">contains</a> (const K &amp;key) const</td></tr>
<tr class="separator:a90f5653e37108274b91d34666a9ef7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68862ad41770b6bf845c663fc119a340"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a68862ad41770b6bf845c663fc119a340"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a68862ad41770b6bf845c663fc119a340">contains</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a68862ad41770b6bf845c663fc119a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae442941c8eb016435f66dded57c1fbc8"><td class="memItemLeft" align="right" valign="top"><a id="ae442941c8eb016435f66dded57c1fbc8"></a>
std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>
<tr class="separator:ae442941c8eb016435f66dded57c1fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a3625f26abb12ef09c41e18a12bbef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a75a3625f26abb12ef09c41e18a12bbef">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a75a3625f26abb12ef09c41e18a12bbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ff69af2f016680ef22beb1d4e6c9a9"><td class="memItemLeft" align="right" valign="top"><a id="ae6ff69af2f016680ef22beb1d4e6c9a9"></a>
std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const</td></tr>
<tr class="separator:ae6ff69af2f016680ef22beb1d4e6c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95b8ec1f1f4432b5b26ff5a83db5b0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3c95b8ec1f1f4432b5b26ff5a83db5b0">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a3c95b8ec1f1f4432b5b26ff5a83db5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2a9aca80e60c35f6a876f87015c335"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5a2a9aca80e60c35f6a876f87015c335"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5a2a9aca80e60c35f6a876f87015c335">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:a5a2a9aca80e60c35f6a876f87015c335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a80cd49bbc9a568fe78c14e7d80b81c9c">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f0385f77d78519f0eb6270cb70d62"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ada7f0385f77d78519f0eb6270cb70d62"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ada7f0385f77d78519f0eb6270cb70d62">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:ada7f0385f77d78519f0eb6270cb70d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa6f8c028631f989a0ba04df9a6e66a04">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9889c1abde8a4980dcedca11a4da90a"><td class="memItemLeft" align="right" valign="top"><a id="ad9889c1abde8a4980dcedca11a4da90a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_count</b> () const</td></tr>
<tr class="separator:ad9889c1abde8a4980dcedca11a4da90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaddfe46e1e201edceb2f46d17cfafe"><td class="memItemLeft" align="right" valign="top"><a id="adbaddfe46e1e201edceb2f46d17cfafe"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_bucket_count</b> () const</td></tr>
<tr class="separator:adbaddfe46e1e201edceb2f46d17cfafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da7f251fd80a9091d334adcb5aeaede"><td class="memItemLeft" align="right" valign="top"><a id="a7da7f251fd80a9091d334adcb5aeaede"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>load_factor</b> () const</td></tr>
<tr class="separator:a7da7f251fd80a9091d334adcb5aeaede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba63be49c8de3e2d799b2118bad8f71"><td class="memItemLeft" align="right" valign="top"><a id="adba63be49c8de3e2d799b2118bad8f71"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> () const</td></tr>
<tr class="separator:adba63be49c8de3e2d799b2118bad8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff78801e693da6fdbf73b617c16ec6e"><td class="memItemLeft" align="right" valign="top"><a id="abff78801e693da6fdbf73b617c16ec6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> (float ml)</td></tr>
<tr class="separator:abff78801e693da6fdbf73b617c16ec6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc309424677397325af4476ac31e1500"><td class="memItemLeft" align="right" valign="top"><a id="acc309424677397325af4476ac31e1500"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rehash</b> (size_type count)</td></tr>
<tr class="separator:acc309424677397325af4476ac31e1500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a62a8db59d69fb9b6f930c15427a0e"><td class="memItemLeft" align="right" valign="top"><a id="ab9a62a8db59d69fb9b6f930c15427a0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_type count)</td></tr>
<tr class="separator:ab9a62a8db59d69fb9b6f930c15427a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582155198c43ed0328394c589274a31"><td class="memItemLeft" align="right" valign="top"><a id="a7582155198c43ed0328394c589274a31"></a>
hasher&#160;</td><td class="memItemRight" valign="bottom"><b>hash_function</b> () const</td></tr>
<tr class="separator:a7582155198c43ed0328394c589274a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efaa0821707a99f0601f59015e719ae"><td class="memItemLeft" align="right" valign="top"><a id="a5efaa0821707a99f0601f59015e719ae"></a>
key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_eq</b> () const</td></tr>
<tr class="separator:a5efaa0821707a99f0601f59015e719ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866c9d599658f12dba6b17fed1b671d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7866c9d599658f12dba6b17fed1b671d">mutable_iterator</a> (const_iterator pos)</td></tr>
<tr class="separator:a7866c9d599658f12dba6b17fed1b671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c67f752a07ced3348b0bc9a5afa3a"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adc4c67f752a07ced3348b0bc9a5afa3a">nth</a> (size_type index)</td></tr>
<tr class="separator:adc4c67f752a07ced3348b0bc9a5afa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2011ea9a10cc9f3e51fea95580abe1"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aba2011ea9a10cc9f3e51fea95580abe1">nth</a> (size_type index) const</td></tr>
<tr class="separator:aba2011ea9a10cc9f3e51fea95580abe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6601e0f32a8a36628753bfcbc096be0f"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6601e0f32a8a36628753bfcbc096be0f">front</a> () const</td></tr>
<tr class="separator:a6601e0f32a8a36628753bfcbc096be0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac182e91cae21e14dc0c2913779cf5368"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac182e91cae21e14dc0c2913779cf5368">back</a> () const</td></tr>
<tr class="separator:ac182e91cae21e14dc0c2913779cf5368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memTemplParams" colspan="2">template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memTemplItemLeft" align="right" valign="top">const values_container_type::value_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data</a> () const noexcept</td></tr>
<tr class="separator:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc951514a5c4c29c14b6cf5177cf1ec"><td class="memItemLeft" align="right" valign="top">const values_container_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container</a> () const noexcept</td></tr>
<tr class="separator:a1bc951514a5c4c29c14b6cf5177cf1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memTemplParams" colspan="2"><a id="a6182f68f6d191ba2c957daea2fbe32dc"></a>
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="separator:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1cb2ec551059e1316532205c461a7"><td class="memItemLeft" align="right" valign="top"><a id="ad3f1cb2ec551059e1316532205c461a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="separator:ad3f1cb2ec551059e1316532205c461a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03dd4f519aaaa11716a3eb3a7132446"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af03dd4f519aaaa11716a3eb3a7132446">insert_at_position</a> (const_iterator pos, const value_type &amp;value)</td></tr>
<tr class="separator:af03dd4f519aaaa11716a3eb3a7132446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9f958a17a59a693569a0519685fc0a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aae9f958a17a59a693569a0519685fc0a">insert_at_position</a> (const_iterator pos, value_type &amp;&amp;value)</td></tr>
<tr class="separator:aae9f958a17a59a693569a0519685fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227c222d9754fccd991600f109b86aea"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a227c222d9754fccd991600f109b86aea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a227c222d9754fccd991600f109b86aea">emplace_at_position</a> (const_iterator pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a227c222d9754fccd991600f109b86aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae440c07d0c3401bb8a1e672cda9d39d8"><td class="memItemLeft" align="right" valign="top"><a id="ae440c07d0c3401bb8a1e672cda9d39d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="separator:ae440c07d0c3401bb8a1e672cda9d39d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc16543a99e892512b9119375c0fe5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a96fc16543a99e892512b9119375c0fe5">unordered_erase</a> (iterator pos)</td></tr>
<tr class="separator:a96fc16543a99e892512b9119375c0fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0e19fd5e5e8832c522b6f876d2a7f9"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4c0e19fd5e5e8832c522b6f876d2a7f9">unordered_erase</a> (const_iterator pos)</td></tr>
<tr class="separator:a4c0e19fd5e5e8832c522b6f876d2a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89a8c07da6b74f3dd737a77366d49cf"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae89a8c07da6b74f3dd737a77366d49cf">unordered_erase</a> (const key_type &amp;key)</td></tr>
<tr class="separator:ae89a8c07da6b74f3dd737a77366d49cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b291ce4c12967996a10646ded0d352c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a9b291ce4c12967996a10646ded0d352c">unordered_erase</a> (const key_type &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a9b291ce4c12967996a10646ded0d352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b30fbcf395a674198bc7943bb04d756"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b30fbcf395a674198bc7943bb04d756"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2b30fbcf395a674198bc7943bb04d756">unordered_erase</a> (const K &amp;key)</td></tr>
<tr class="separator:a2b30fbcf395a674198bc7943bb04d756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979b730573d4d61fd42df217b8bccd20"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a979b730573d4d61fd42df217b8bccd20"><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a979b730573d4d61fd42df217b8bccd20">unordered_erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a979b730573d4d61fd42df217b8bccd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memTemplParams" colspan="2">template&lt;class Serializer &gt; </td></tr>
<tr class="memitem:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6a50408f6297bc6ecb05c7a0942bb581">serialize</a> (Serializer &amp;serializer) const</td></tr>
<tr class="separator:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memTemplParams" colspan="2">template&lt;class Deserializer &gt; </td></tr>
<tr class="memitem:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aaf995efb5c45de92a8ef1d35f6e7e28e">deserialize</a> (Deserializer &amp;deserializer, bool hash_compatible=false)</td></tr>
<tr class="separator:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memItemLeft" align="right" valign="top"><a id="aa58b43c0c001cea18c9b7d7714b9d85c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca13b71af5e35082b3e22c01680844"><td class="memItemLeft" align="right" valign="top"><a id="aafca13b71af5e35082b3e22c01680844"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aafca13b71af5e35082b3e22c01680844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memItemLeft" align="right" valign="top"><a id="ad685a66cbb7c59a0923ca7d57a734c27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506164f732a96dfefef194dd47c5459d"><td class="memItemLeft" align="right" valign="top"><a id="a506164f732a96dfefef194dd47c5459d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a506164f732a96dfefef194dd47c5459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59796ffdc4400bdcb82073c952cdf451"><td class="memItemLeft" align="right" valign="top"><a id="a59796ffdc4400bdcb82073c952cdf451"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a59796ffdc4400bdcb82073c952cdf451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memItemLeft" align="right" valign="top"><a id="a94a17aeb7a1827b4f3cc26552ddb9db0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memItemLeft" align="right" valign="top"><a id="a5fb2c2dd5207da0a8b606fc11fa6dba8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, class ValueTypeContainer = std::deque&lt;Key, Allocator&gt;, class IndexType = std::uint_least32_t&gt;<br />
class tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;</h3>

<p>Implementation of an hash set using open addressing with robin hood with backshift delete to resolve collisions.</p>
<p>The particularity of this hash set is that it remembers the order in which the elements were added and provide a way to access the structure which stores these values through the '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>' method. The used container is defined by ValueTypeContainer, by default a std::deque is used (grows faster) but a std::vector may be used. In this case the set provides a '<a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data()</a>' method which give a direct access to the memory used to store the values (which can be useful to communicate with C API's).</p>
<p>The Key must be copy constructible and/or move constructible. To use <code>unordered_erase</code> it also must be swappable.</p>
<p>The behaviour of the hash set is undefined if the destructor of Key throws an exception.</p>
<p>By default the maximum size of a set is limited to 2^32 - 1 values, if needed this can be changed through the IndexType template parameter. Using an <code>uint64_t</code> will raise this limit to 2^64 - 1 values but each bucket will use 16 bytes instead of 8 bytes in addition to the space needed to store the values.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators (also invalidate end()).</li>
<li>insert, emplace, emplace_hint, operator[]: when a std::vector is used as ValueTypeContainer and if size() &lt; capacity(), only end(). Otherwise all the iterators are invalidated if an insert occurs.</li>
<li>erase, unordered_erase: when a std::vector is used as ValueTypeContainer invalidate the iterator of the erased element and all the ones after the erased element (including end()). Otherwise all the iterators are invalidated if an erase occurs. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac182e91cae21e14dc0c2913779cf5368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac182e91cae21e14dc0c2913779cf5368">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the last element. Requires the container to not be empty. </p>

</div>
</div>
<a id="a95347e23841cb607b1fe291da16a045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95347e23841cb607b1fe291da16a045a">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a90f5653e37108274b91d34666a9ef7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f5653e37108274b91d34666a9ef7a9">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a68862ad41770b6bf845c663fc119a340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68862ad41770b6bf845c663fc119a340">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a6671d647ef9402361c009af2f47e29ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6671d647ef9402361c009af2f47e29ba">&#9670;&nbsp;</a></span>count() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a766cac50caed1afe6b1dbb2c6447a55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766cac50caed1afe6b1dbb2c6447a55b">&#9670;&nbsp;</a></span>count() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aced79117d7534ed3ab2d6a237a0058bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced79117d7534ed3ab2d6a237a0058bc">&#9670;&nbsp;</a></span>count() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3ec9980b152c71a875fc4a4e1d7bb78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec9980b152c71a875fc4a4e1d7bb78c">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const values_container_type::value_type* <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only available if ValueTypeContainer is a std::vector. Same as calling '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>.<a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data()</a>'. </p>

</div>
</div>
<a id="aaf995efb5c45de92a8ef1d35f6e7e28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf995efb5c45de92a8ef1d35f6e7e28e">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class Deserializer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::deserialize </td>
          <td>(</td>
          <td class="paramtype">Deserializer &amp;&#160;</td>
          <td class="paramname"><em>deserializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hash_compatible</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deserialize a previously serialized set through the <code>deserializer</code> parameter.</p>
<p>The <code>deserializer</code> parameter must be a function object that supports the following calls:</p><ul>
<li><code>template&lt;typename U&gt; U operator()();</code> where the types <code>std::uint64_t</code>, <code>float</code> and <code>Key</code> must be supported for U.</li>
</ul>
<p>If the deserialized hash set type is hash compatible with the serialized set, the deserialization process can be sped up by setting <code>hash_compatible</code> to true. To be hash compatible, the Hash and KeyEqual must behave the same way than the ones used on the serialized map. The <code>std::size_t</code> must also be of the same size as the one on the platform used to serialize the map, the same apply for <code>IndexType</code>. If these criteria are not met, the behaviour is undefined with <code>hash_compatible</code> sets to true.</p>
<p>The behaviour is undefined if the type <code>Key</code> of the <code><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a></code> is not the same as the type used during serialization.</p>
<p>The implementation leaves binary compatibility (endianness, IEEE 754 for floats, size of int, ...) of the types it deserializes in the hands of the <code>Deserializer</code> function object if compatibility is required. </p>

</div>
</div>
<a id="ad4a8ee2e57f3c30fe19b326a874f0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a8ee2e57f3c30fe19b326a874f0bd5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a227c222d9754fccd991600f109b86aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227c222d9754fccd991600f109b86aea">&#9670;&nbsp;</a></span>emplace_at_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace_at_position </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and end().</p>
<p>Same as insert_at_position(pos, value_type(std::forward&lt;Args&gt;(args)...), mainly here for coherence. </p>

</div>
</div>
<a id="ad266d5e2425b6af842790944fa75ef76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad266d5e2425b6af842790944fa75ef76">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a75a3625f26abb12ef09c41e18a12bbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a3625f26abb12ef09c41e18a12bbef">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3c95b8ec1f1f4432b5b26ff5a83db5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c95b8ec1f1f4432b5b26ff5a83db5b0">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a5a2a9aca80e60c35f6a876f87015c335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2a9aca80e60c35f6a876f87015c335">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a80cd49bbc9a568fe78c14e7d80b81c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cd49bbc9a568fe78c14e7d80b81c9c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ada7f0385f77d78519f0eb6270cb70d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f0385f77d78519f0eb6270cb70d62">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aa6f8c028631f989a0ba04df9a6e66a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f8c028631f989a0ba04df9a6e66a04">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a91cb7fc84c0bfab1c196109d416bad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb7fc84c0bfab1c196109d416bad85">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a05c3e96aba2834dcc28b22ee8699c914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c3e96aba2834dcc28b22ee8699c914">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a318c0fb661e5e389f82bcb9f157db45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c0fb661e5e389f82bcb9f157db45d">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a4a1e1054dd9e86fc0617070ad35f8d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1e1054dd9e86fc0617070ad35f8d45">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a35895b2267b33386efdc0ccf2b262154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35895b2267b33386efdc0ccf2b262154">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="aabc0464c0f492f1b411fcef7ac396936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc0464c0f492f1b411fcef7ac396936">&#9670;&nbsp;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a7e0e6377f984cd852e8861174fc28786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0e6377f984cd852e8861174fc28786">&#9670;&nbsp;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup to the value if you already have the hash.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="abe63aacec0b31672f70753f20c7e0d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe63aacec0b31672f70753f20c7e0d8b">&#9670;&nbsp;</a></span>find() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="aaef6331a007f7a8848b5dabc89238946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef6331a007f7a8848b5dabc89238946">&#9670;&nbsp;</a></span>find() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a46c6728c8839d9bfcec8785a3a918d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c6728c8839d9bfcec8785a3a918d33">&#9670;&nbsp;</a></span>find() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aced9be09be40ecc1b2b53148fdbeae3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced9be09be40ecc1b2b53148fdbeae3c">&#9670;&nbsp;</a></span>find() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a32f4eb260419db865a600bb927fde308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f4eb260419db865a600bb927fde308">&#9670;&nbsp;</a></span>find() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a9b56494c36c62b257971a5c89ce43ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b56494c36c62b257971a5c89ce43ace">&#9670;&nbsp;</a></span>find() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a6601e0f32a8a36628753bfcbc096be0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6601e0f32a8a36628753bfcbc096be0f">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the first element. Requires the container to not be empty. </p>

</div>
</div>
<a id="af03dd4f519aaaa11716a3eb3a7132446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03dd4f519aaaa11716a3eb3a7132446">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and end(). </p>

</div>
</div>
<a id="aae9f958a17a59a693569a0519685fc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9f958a17a59a693569a0519685fc0a">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and end(). </p>

</div>
</div>
<a id="a7866c9d599658f12dba6b17fed1b671d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7866c9d599658f12dba6b17fed1b671d">&#9670;&nbsp;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="adc4c67f752a07ced3348b0bc9a5afa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c67f752a07ced3348b0bc9a5afa3a">&#9670;&nbsp;</a></span>nth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::nth </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requires index &lt;= size().</p>
<p>Return an iterator to the element at index. Return end() if index == size(). </p>

</div>
</div>
<a id="aba2011ea9a10cc9f3e51fea95580abe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2011ea9a10cc9f3e51fea95580abe1">&#9670;&nbsp;</a></span>nth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::nth </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Requires index &lt;= size().</p>
<p>Return an iterator to the element at index. Return end() if index == size(). </p>

</div>
</div>
<a id="a6a50408f6297bc6ecb05c7a0942bb581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a50408f6297bc6ecb05c7a0942bb581">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class Serializer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Serializer &amp;&#160;</td>
          <td class="paramname"><em>serializer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize the set through the <code>serializer</code> parameter.</p>
<p>The <code>serializer</code> parameter must be a function object that supports the following call:</p><ul>
<li><code>void operator()(const U&amp; value);</code> where the types <code>std::uint64_t</code>, <code>float</code> and <code>Key</code> must be supported for U.</li>
</ul>
<p>The implementation leaves binary compatibility (endianness, IEEE 754 for floats, ...) of the types it serializes in the hands of the <code>Serializer</code> function object if compatibility is required. </p>

</div>
</div>
<a id="a96fc16543a99e892512b9119375c0fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc16543a99e892512b9119375c0fe5">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="a4c0e19fd5e5e8832c522b6f876d2a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0e19fd5e5e8832c522b6f876d2a7f9">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="ae89a8c07da6b74f3dd737a77366d49cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89a8c07da6b74f3dd737a77366d49cf">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="a9b291ce4c12967996a10646ded0d352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b291ce4c12967996a10646ded0d352c">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2b30fbcf395a674198bc7943bb04d756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b30fbcf395a674198bc7943bb04d756">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a979b730573d4d61fd42df217b8bccd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979b730573d4d61fd42df217b8bccd20">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as hash_function()(key). Useful to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a1bc951514a5c4c29c14b6cf5177cf1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc951514a5c4c29c14b6cf5177cf1ec">&#9670;&nbsp;</a></span>values_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const values_container_type&amp; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::values_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the container in which the values are stored. The values are in the same order as the insertion order and are contiguous in the structure, no holes (size() == <a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>.size()). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/dante/Documents/Projects/grand-blue-engine/reverie/src/third_party/tsl/<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
