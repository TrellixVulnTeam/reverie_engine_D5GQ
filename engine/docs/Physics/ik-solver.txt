// See: http://soliduscode.com/iksolver-class/
// http://soliduscode.com/using-jacobian-for-inverse-kinematics/

package app.skeletalanimation.ik;

import com.soliduscode.common.lib.math.Vector3f;

public class IKSolver {
    /**
     *  6 x nJoints Matrix
     *  6 degrees of freedom
     * A collection of partial derivatives that describes
     * how the end effector changes position and orientation
     * with respect to changes in joint[i] orientation changes.
     * 
     *  Matrix = 6 x numJoints
     *           [ x0 -&#x3E; ...  ]
     *           [ y0 --&#x3E; ... ]
     *           [ z0 --&#x3E; ... ]
     *  Matrix = [ a0 --&#x3E; ... ] , where a0,a1,a2 are theta orientation, matrix is column major
     *           [ a1 --&#x3E; ... ]   describing each joint
     *           [ a2 --&#x3E; ... ]
     *
     *
     * 
     *  6 is the number of Degree of freedom for each joint.
     * 3 for position and 3 for orientation
     */
&#x9;public DynamicMatrix m_Jacobian = null;
&#x9;/**
&#x9; * Describes the inverse of Jacobian.  Used to 
&#x9; * give the needed changes in orientation that effectuates
&#x9; * end effector to reach goal.
&#x9; * 
&#x9; * Matrix = numJoints x 6
     *
     *
     * Matrix = [  a  |
     *              \|/ ]
     *
     *
     *
&#x9; */
    public DynamicMatrix m_JacobianTranspose = null;
    
    /**
     *   6 x 1 Matrix
     * Holds the directional pull of the end effector 
     * towards the goal.
     */
    public DynamicMatrix m_farrError = null;
    /**
     * A vector of joint velocities.  Each entry in this
     * matrix is representative of the angle (in radians)
     * that cause the End Effector to reach the target (goal).
     */
    public DynamicMatrix m_QDerivative = null;&#x9;//Joint rotation angles
    /**
     * For each joint in the IKChain, the axis around which the
     * joint rotates about is calculated and saved.  This 
     * axis is derived from;
     * 
     * 
     *
     *
     *     Array of Axis where each entry represents joint[i] rotation axis
     *     axis = &#x3C;i&#x3E;Normalise&#x3C;/i&#x3E;( (effector - joint_i) x (goal - joint_i) )
     *
     *  
     */
    public Vector3f[] m_arrAxis&#x9;&#x9;&#x9;&#x9; &#x9;= null;
    /**
     * Indicates the number of possible interactions
     * that should be attempted and continued until the
     * IKSolver is forced to terminate, whether a solution
     * (end effector reaches the goal) was found or not.
     */
    public int &#x9;&#x9;&#x9;m_iTryLimit&#x9;&#x9; ;
    /**
     * Describes the acceptable distance between the
     * end effector and the target goal.  In short,
     * used to terminate the IKSolver iteration if 
     * the distance between target and end effector
     * is less than this value.
     */
    public float &#x9;&#x9;m_fTargetThreshold &#x9; ;
    
    /**
     * &#x3C;p&#x3E;Overall, this is the step rate for the changes in orientation&#x3C;/p&#x3E;
     * &#x3C;p&#x3E;
     * Describes how quickly the derived angles will rotate in
     * attempts to cause the end effector to reach the target.&#x3C;/p&#x3E;
     * 
     * &#x3C;p&#x3E;
     * The Smaller the value, the more smooth and controlled the 
     * transition will be towards the target.  The larger the value
     * the more erratic the transition will be towards the target.&#x3C;/p&#x3E;
     */

&#x9;public float integration = 0.0005f;
    /**
     * The number of times the IKSolver will iterate before 
     * forcing stop of execution of the jacobian.  
     *
     */
    public int iTries&#x9;= 0;

    public IKSolver(int nJoints){
    &#x9;m_Jacobian = new &#x9;DynamicMatrix(6,nJoints);
    &#x9;m_farrError              = new&#x9;DynamicMatrix(6,1);
    &#x9;m_QDerivative = new &#x9;DynamicMatrix(nJoints,1);
    &#x9;m_arrAxis&#x9;&#x9;&#x9;&#x9; = new  Vector3f[nJoints];

    &#x9;iTries &#x9;&#x9;&#x9;&#x9;&#x9; = 0;
        m_fTargetThreshold &#x9;&#x9;= 1.5f;
        m_iTryLimit&#x9;&#x9;&#x9; &#x9;= 4;
    }
}