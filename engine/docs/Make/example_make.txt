# The GNU Make Manual: https://www.gnu.org/software/make/manual/make.html
# Place to start https://www.gnu.org/software/make/manual/html_node/Makefile-Contents.html
# Variables used by implicit rules: https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html
# The options that make understands: https://www.gnu.org/software/make/manual/html_node/Options-Summary.html
# By default, when make looks for the makefile, it tries the following names, in order: GNUmakefile, makefile and Makefile.  "Makefile" is preferred
# 4.9 - Special Built-In target names

# Options --------------------------------------------------------------------
# Options are passed automatically to sub-makes through the variable MAKEFLAGS, which processes them as if they'd been given as arguments
# The ‘-n’, ‘-t’, and ‘-q’ options do not affect recipe lines that begin with ‘+’ characters or contain the strings ‘$(MAKE)’ or ‘${MAKE}’. Note that only the line containing the ‘+’ character or the strings ‘$(MAKE)’ or ‘${MAKE}’ is run regardless of these options. Other lines in the same rule are not run unless they too begin with ‘+’ or contain ‘$(MAKE)’ or ‘${MAKE}’.  Note that these options ARE passed to sub-make
# The options ‘-C’, ‘-f’, ‘-o’, and ‘-W’ are not put into MAKEFLAGS; these options are not passed down. 
# -f ~ read the file named file as a makefile, e.g., -f file, --makefile=file
# -o ~ e.g., -o file, do not remake the file "file" even if it is older than its prerequisites
# -O ~ Ensure that the complete output from each recipe is printed in one uninterrupted sequence
# -W ~ pretend that a target file has bee modified
# -C ~ enter given subdirectory before executing command, e.g., cd subdir && $(MAKE) == $(MAKE) -C subdir
# -n ~ No-op, causues make to print the recipes that are needed to bring targets up-to-date, but not execute them
# -t ~ touch, marks targets as up-to-date without actually changing them
# -q ~ question, silently checks whether the targets are up-to-date, but does not execute recipes
# -e ~ Give variables taken from the environment precedence over variables from makefiles
# -s ~ silent operation, do not print recipes as they are executed
# -k ~ keep going, continue as much as possible after an error
# -j N ~ run N jobs in parallel, will be passed to sub-makes if system supports it and no N is specified (infinite jobs are infinite)
# -MM ~ omits prerequisites on system header files

# Automatic Variables/Symbols --------------------------------------------------------------------
# @ is the make syntax, which does not echo the command starting with @, i.e., @ simply suppressed output
# % is a pattern rule, i.e., a makefile internal wildcard which will serve as a placeholder in a for-each manner. a pattern of just ‘%’ will match any target whatever
# 	e.g., %.o: %.c
#         	$(CC) $(CFLAGS) -c -o $@ $<
# The above specifies that in order to build something whose file name ends with ".o", a file with the same prefix, but ending in ".c" is needed
# "$@" means "the target of this rule", specifically the file anme of the target
# "$%" means "the target member name", which is when the target is an archive member. Empty otherwise
# "$<" means "this rule's first listed prerequisite", e.g. "%.c" in the above example
# "$?" gives the name of all prerequisites that ar enewer than the target, with spaces between them.  If the target doesn't exist, all prerequisites are included
# "$^" means "all of this rule's prerequisites", without duplicates
# "$+" like the previous, but allows duplicates

# Bash -----------------------------------------------------------------------
# : is the null command
# * is a wildcard which gets you a list and is "shell" relates.
# ar command: https://www.geeksforgeeks.org/ar-command-in-linux-with-examples/
# mv file1 file2 ~ moves file1 to the location specified by file2
# nm ~ list symbols for object files

# Constants ------------------------------------------------------------------
CC=gcc # the compiler to use
CFLAGS=-I. # the list of flags to pass to the compilation command, -I specifies a directory to search for include make files, so this searches the directory that the makefile is in
DEPS = hellomake.h

# Make variables -------------------------------------------------------------
# -Note that variables are case-sensitive
# -Can be recursively expanded (=) (contains references), or simply expanded) (:=), or (::=), the former of which is not supported by POSIX.  Simply expanded variables only contain values from the time of definition
# ?= will define a variable only if it is not already defined
# Target-specific variable: "target … : variable-assignment"
# For special variables, see: https://www.gnu.org/software/make/manual/make.html#Special-Variables :

# VPATH ~ specifies a list of directories that make should search
# MAKEFILES ~ an environmental variable, much like include, except that the default goal is never taken from one of the makefiles included, and it is not an error if a makefile is not found
#    Is used for recursive invocations of make
# MAKE ~ calls "make", should always be used over the explicit command "make".  The value of this variable is the file name with which "make" was invoked
# Exporting to submakes:
#	MAKEFLAGS is always exported, MAKEFILES is as well if it is set to anything
#	make automatically passes down variable values that were defined on the command line by putting them in the MAKEFLAGS variable
# MAKELEVEL ~ the level of the make, a string which starts at "0" at the top-level and is incremented for each sub-make

# Directives -----------------------------------------------------------------
# include ~ include filenames... # This will read one or more of the specified makefiiles before continuing, filenames can contain shell file name patterns
# Line must not begin with a tab, or it will be considered a recipe (can use spaces)
# Variables are expanded, e.g., include foo *.mk $(bar), where bar expands to bish bash, becomes include foo a.mk b.mk c.mk bish bash
# To avoid raising errors or warnings if filenames aren't found, prepend "-" to the command, e.g. -include filenames...
# vpath ~ Similar to the VPATH variable, but more selective, is the vpath directive (note lower case), which allows you to specify a search path for a particular class of file names: those that match a particular pattern
# export ~ passes down a variable to a sub-make, unless variable is mentioned in an unexport call. If left blank, variables containing only alpha-numerics and underscores will be exported
# override ~ allows a variable that was set with a command argument to be reassigned
# define ~ define a multi-line variable
# undefine ~ undefine a variable

# Functions ------------------------------------------------------------------
# shell ~ unlike every function other than wildcard, communicates with world outside of make, does what backquote "`" does in shells, command expansion, i.e., takes an argument as a shell command and evaluates to the output of the command
# origin ~ tells you where a variable came form

# Rules ----------------------------------------------------------------------
# Rules take the form:
# target: usually name of the file generated
# prerequisites: a file used as an input to create target
# recipe: the action for the make to carry out
# target ... : prerequisites ...
# 	recipe
#	...
# or targets : prerequisites ; recipe
#        recipe
# -An empty recipe will stop make from searching for an implicit rule, e.g. target: ;
# -A recipe consists of one or more shell command lines to be executed, one at a time, in the order they appear, and are interpreted by interpreted by /bin/sh, unless specified otherwise
# -A macro can expand from an entire rule if the rule is one line long, e.g. myrule = target : ; echo built.  Then to expand the macro, $(myrule)
# -Make files are parsed line-by-line, use "secondary expansion" to reassign variables out of line order
# -Multiple targets can be assigned to a recipe
# -Useful pre-build rules: .DELETE_ON_ERROR, .PHONY

%.o: %.c $(DEPS) # Dollar sign expands out the defined variable
	$(CC) -c -o $@ $< $(CFLAGS)

	
# The default goal is the first target that does not start with ".", make starts with this, and the ultimate goal is to update this target
hellomake: hellomake.o hellofunc.o 
	$(CC) -o hellomake hellomake.o hellofunc.o 
	
# Recipes for .c to .o files can be left out entirely, due to implicit rules
	
# Phony target, will be executed every time the target comes up for remaking
# If not explicitly declared phony, will not work if a file named clean is ever in this directory
# No prerequisites, so if a file clean exists, it is always considered up to date
.PHONY: clean # Will now run regardless of whether or not there is a file named clean
# To ignore errors in a recipe line, write a ‘-’ at the beginning of the line’s text (after the initial tab). The ‘-’ is discarded before the line is passed to the shell for execution. 
clean: 
	-rm *.o temp # Does not create a file named clean, so is called on every 'make clean'
# An identical pattern to this is:
#clean: FORCE
#        rm $(objects)
#FORCE: