///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Includes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "GTransformComponents.h"

// Standard Includes

// External

// Project
#include "GTransform.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Namespace Definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace rev {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Using definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Implementations
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Affine component
//AffineComponent::AffineComponent(TransformComponentType type):
//    AbstractTransformComponent(type)
//{
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//void AffineComponent::loadFromJson(const QJsonValue & json, const SerializationContext & context)
//{
//    AbstractTransformComponent::loadFromJson(json, context);
//}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//void AffineComponent::computeTransformMatrix(bool updateTransform)
//{
//    if (m_transform && updateTransform) {
//        m_transform->computeWorldMatrix();
//    }
//}
//


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Scale component
ScaleComponent::ScaleComponent():
    m_scale(1, 1, 1)
{
    //AffineComponent::computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent::ScaleComponent(Transform* transform, const rev::Matrix4x4 & scaling)
{
    m_transformMatrix = scaling;
    computeTransformMatrix(transform);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent::ScaleComponent(Transform* transform, const rev::Vector3 & scaling):
    m_scale(scaling)
{
    computeTransformMatrix(transform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(Transform* transform, double x, double y, double z, bool updateTransform)
{
    m_scale = { float(x), float(y), float(z) };
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(Transform* transform, const rev::Vector3 & scaling, bool updateTransform)
{
    m_scale = scaling;
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::setScale(Transform* transform, double scaling, bool updateTransform)
{
    m_scale = rev::Vector3(1, 1, 1) * scaling;
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue ScaleComponent::asJson(const SerializationContext& context) const
{
    QJsonObject object;
    object.insert("scaling", m_scale.asJson());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::loadFromJson(const QJsonValue& json, const SerializationContext& context)
{
    Transform* t = reinterpret_cast<Transform*>(context.m_data);
    const QJsonObject & object = json.toObject();
    Vector3 scaling(object.value("scaling"));
    setScale(t, scaling);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScaleComponent::computeTransformMatrix(Transform* transform, bool updateTransform)
{
    //m_transformMatrix.setToIdentity();
    //m_transformMatrix.addScale(m_scale.asReal());
    m_transformMatrix(0, 0) = m_scale[0];
    m_transformMatrix(1, 1) = m_scale[1];
    m_transformMatrix(2, 2) = m_scale[2];

    if (transform && updateTransform) {
        transform->computeWorldMatrix();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent():
    m_quaternion(0, 0, 0, 1)
{
    //computeTransformMatrix();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent(Transform* transform, const rev::Quaternion & quaternion) :
    m_quaternion(quaternion)
{
    computeTransformMatrix(transform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::RotationComponent(Transform* transform, const EulerAngles & eulerAngles)
{
    computeTransformMatrix(transform, eulerAngles);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent::~RotationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::addRotation(Transform* transform, const EulerAngles & eulerAngles, bool updateTransform)
{
    Matrix4x4 addedRotation = eulerAngles.toRotationMatrixF();
    m_transformMatrix = addedRotation * m_transformMatrix;
    m_quaternion = Quaternion::fromRotationMatrix(m_transformMatrix);
    if (transform && updateTransform) {
        transform->computeWorldMatrix();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::setRotation(Transform* t, const Quaternion & quaternion, bool updateTransform)
{
    m_quaternion = quaternion;
    computeTransformMatrix(t, updateTransform);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::setRotation(Transform* t, const EulerAngles & eulerAngles, bool updateTransform)
{
    computeTransformMatrix(t, eulerAngles);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue RotationComponent::asJson(const SerializationContext& context) const
{
    QJsonObject object;
    object.insert("quaternion", m_quaternion.asJson());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::loadFromJson(const QJsonValue& json, const SerializationContext& context)
{
    Transform* t = reinterpret_cast<Transform*>(context.m_data);
    setRotation(t, Quaternion(json.toObject()["quaternion"]));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::computeTransformMatrix(Transform* transform, bool updateTransform)
{
    m_quaternion.toRotationMatrix(m_transformMatrix);
    if (transform && updateTransform) {
        transform->computeWorldMatrix();
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RotationComponent::computeTransformMatrix(Transform* transform, const EulerAngles & eulerAngles, bool updateTransform)
{
    m_transformMatrix = eulerAngles.toRotationMatrixF();
    setRotation(transform, Quaternion::fromRotationMatrix(m_transformMatrix));
    if (transform && updateTransform) {
        transform->computeWorldMatrix();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Translation 
Translation::Translation():
    //m_frame(kGLWorld),
    m_position(0, 0, 0)
    //m_velocity(0, 0, 0),
    //m_acceleration(0, 0, 0)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const QJsonValue & json)
{
    loadFromJson(json);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const Vector3 & position, CoordinateFrame frame ):
    m_position(position)
    //m_frame(frame)
{
    Q_UNUSED(frame);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Translation::Translation(const Vector3 & position, const Vector3 & velocity, const Vector3 & acceleration, CoordinateFrame frame):
//    m_position(position)
//    //m_velocity(velocity),
//    //m_acceleration(acceleration),
//    //m_frame(frame)
//{
//    Q_UNUSED(frame);
//    Q_UNUSED(velocity);
//    Q_UNUSED(acceleration);
//}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::Translation(const Translation & t):
    m_position(t.m_position)
    //m_velocity(t.m_velocity),
    //m_acceleration(t.m_acceleration),
    //m_frame(t.m_frame)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation::~Translation()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator+(const Translation & t) const
{
    //if (m_frame != t.m_frame) throw("Error, coordinate frames must match");
    //return Translation(m_position + t.m_position,
    //    m_velocity + t.m_velocity,
    //    m_acceleration + t.m_acceleration,
    //    m_frame);
    return Translation(m_position + t.m_position);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator-(const Translation & t) const
{
    //if (m_frame != t.m_frame) throw("Error, coordinate frames must match");
    //return Translation(m_position - t.m_position, 
    //    m_velocity - t.m_velocity, 
    //    m_acceleration - t.m_acceleration, 
    //    m_frame);
    return Translation(m_position - t.m_position);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator*(double c) const
{
    return Translation(std::move(m_position * c));
    //return Translation(m_position * c, m_velocity * c, m_acceleration * c);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Translation Translation::operator/(double c) const
{
    return Translation(std::move(m_position / c));
    //return Translation(m_position / c, m_velocity / c, m_acceleration / c);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue Translation::asJson(const SerializationContext& context) const
{
    QJsonObject object;
    object.insert("position", m_position.asJson());
    //object.insert("velocity", m_velocity.asJson());
    //object.insert("acceleration", m_acceleration.asJson());
    //object.insert("frame", int(m_frame));
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Translation::loadFromJson(const QJsonValue& json, const SerializationContext& context)
{
    Q_UNUSED(context)

    const QJsonObject& object = json.toObject();
    m_position = Vector3(object["position"]);
    //m_velocity = Vector3(object["velocity"]);
    //m_acceleration = Vector3(object["acceleration"]);
    //m_frame = CoordinateFrame(object["frame"].toInt());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
std::ostream & operator<<(std::ostream & os, const Translation & t)
{
    return os << "Translation("
        << "position: " << t.m_position
        //<< "velocity: " << t.m_velocity
        //<< "acceleration: " << t.m_acceleration
        << ")";
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Translation component
TranslationComponent::TranslationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent::TranslationComponent(const Vector3 & translation)
{
    m_translation = translation;
    //computeTransformMatrix();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent::~TranslationComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//void TranslationComponent::addTranslation(const Vector3g & position, bool updateTransform)
//{
//    m_translation.m_position += position;
//    if (m_transform && updateTransform) {
//        m_transform->computeWorldMatrix();
//    }
//}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setPosition(Transform* transform, const Vector3 & p, bool updateTransform)
{
    m_translation.m_position = p;
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setTranslation(Transform* transform, const Translation & position, bool updateTransform)
{
    m_translation = position;
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::setTranslation(Transform* transform, const Vector3 & position, bool updateTransform)
{
    m_translation.m_position = position;
    computeTransformMatrix(transform, updateTransform);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue TranslationComponent::asJson(const SerializationContext& context) const
{
    QJsonObject object;
    object.insert("translation", m_translation.asJson().toObject());
    return object;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::loadFromJson(const QJsonValue& json, const SerializationContext& context)
{
    Transform* t = reinterpret_cast<Transform*>(context.m_data);
    const QJsonObject& object = json.toObject();
    setTranslation(t, Translation(object.value("translation")));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslationComponent::computeTransformMatrix(Transform * transform, bool updateTransform)
{
    if (transform && updateTransform) {
        transform->computeWorldMatrix();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // end namespacing
