#include "GbPyWrappers.h"

#include <QJsonDocument>
#include "../GbPythonAPI.h"
#include "../../GbCoreEngine.h"
#include "../../view/GbWidgetManager.h"
#include "../../view/GL/GbGLWidget.h"

#include "../../events/GbEvent.h"

#include "../../components/GbLightComponent.h"
#include "../../components/GbCameraComponent.h"
#include "../../components/GbShaderComponent.h"
#include "../../components/GbTransformComponent.h"
#include "../../components/GbPhysicsComponents.h"
#include "../../components/GbAudioSourceComponent.h"
#include "../../components/GbAnimationComponent.h"
#include "../../physics/GbCharacterController.h"
#include "../../rendering/view/GbRenderProjection.h"
#include "../../rendering/shaders/GbShaders.h"

#include "../../resource/GbResourceCache.h"
#include "../../scene/GbScenario.h"
#include "../../scene/GbScene.h"
#include "../../scene/GbSceneObject.h"
#include "../../input/GbInputHandler.h"
#include "../../geometry/GbTransformComponents.h"
#include "../../geometry/GbEulerAngles.h"
#include "../../readers/GbJsonReader.h"
#include "../../utils/GbInterpolation.h"

namespace Gb {
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyShaderComponent
/////////////////////////////////////////////////////////////////////////////////////////////
PyShaderComponent::PyShaderComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
ShaderComponent* PyShaderComponent::new_ShaderComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    ShaderComponent* r = new ShaderComponent(objectShared);
    r->setIsPythonGenerated(true);
    return r;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderComponent::delete_ShaderComponent(ShaderComponent* r)
{
    delete r;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyShaderComponent::as_json_str(ShaderComponent* r) const
{
    QString strJson = JsonReader::ToQString(r->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyShaderComponent::py_toString(ShaderComponent* r)
{
    return r->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyBoneAnimation
/////////////////////////////////////////////////////////////////////////////////////////////
PyBoneAnimation::PyBoneAnimation()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
BoneAnimationComponent* PyBoneAnimation::new_BoneAnimationComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    BoneAnimationComponent* c = new BoneAnimationComponent(objectShared);
    c->setIsPythonGenerated(true);
    return c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyBoneAnimation::delete_BoneAnimationComponent(BoneAnimationComponent* c)
{
    delete c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyBoneAnimation::as_json_str(BoneAnimationComponent* c) const
{
    QString strJson = JsonReader::ToQString(c->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyBoneAnimation::scene_object(BoneAnimationComponent * c) const
{
    //const QString& uuid = l->sceneObject()->getUuid().asString();
    return c->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyBoneAnimation::py_toString(BoneAnimationComponent* c)
{
    return c->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyCamera
/////////////////////////////////////////////////////////////////////////////////////////////
PyCamera::PyCamera()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
CameraComponent* PyCamera::new_CameraComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    CameraComponent* c = new CameraComponent(objectShared);
    c->setIsPythonGenerated(true);
    return c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::delete_CameraComponent(CameraComponent * c)
{
    delete c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyCamera::as_json_str(CameraComponent * c) const
{
    QString strJson = JsonReader::ToQString(c->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyCamera::scene_object(CameraComponent * c) const
{
    return c->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::rotate_about_point(CameraComponent * c, Vector3 * point, Vector2 * mouseDelta, double speedFactor)
{
    c->camera().rotateAboutPoint(*point, *mouseDelta, speedFactor);
}
///////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::look_at(CameraComponent * c, Transform * transform, const Vector3* up)
{
    if (!up) {
        c->camera().setLookAt(c->camera().eye(), transform->getPosition(), Vector3::Up());
    }
    else {
        c->camera().setLookAt(c->camera().eye(), transform->getPosition(), *up);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::look_at(CameraComponent * c, Vector3 * pos, const Vector3 * up)
{
    if (!up) {
        c->camera().setLookAt(c->camera().eye(), *pos, Vector3::Up());
    }
    else {
        c->camera().setLookAt(c->camera().eye(), *pos, *up);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyCamera::rotate_about_axis(CameraComponent * c, Vector3* point, Vector3 * axis, Vector2 * mouseDelta, double speedFactor)
//{
//    c->camera().rotateAboutAxis(*point, *axis, *mouseDelta, speedFactor);
//}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyCamera::forward(CameraComponent * c)
{
    // We want forward to mean the look-at direction, which is the opposite of getForwardVec's convention
    return new Vector3(-c->camera().getForwardVec());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyCamera::right(CameraComponent * c)
{
    return new Vector3(c->camera().getRightVec());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyCamera::up(CameraComponent * c)
{
    return new Vector3(c->camera().getUpVec());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_viewport(CameraComponent* c, double x, double y, double w, double h)
{
    c->camera().viewport().m_xn = x;
    c->camera().viewport().m_yn = y;
    c->camera().viewport().m_width = w;
    c->camera().viewport().m_height = h;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_depth(CameraComponent* c, int x)
{
    c->camera().viewport().setDepth(x);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_fov(CameraComponent * c, double fov)
{
    c->camera().renderProjection().setFOV(fov);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyCamera::py_toString(CameraComponent * c)
{
    return c->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
// PyCharacterController
/////////////////////////////////////////////////////////////////////////////////////////////
PyCharacterController::PyCharacterController()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyCharacterController::~PyCharacterController()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::move(CharControlComponent * c, const Vector3 * disp) const
{
    c->move(*disp);
}
/////////////////////////////////////////////////////////////////////////////////////////////
float PyCharacterController::get_radius(CharControlComponent * c) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        return std::static_pointer_cast<CapsuleController>(c->controller())->getRadius();
    }
    else {
        return -1;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyCharacterController::set_radius(CharControlComponent * c, float rad) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        bool done = std::static_pointer_cast<CapsuleController>(c->controller())->setRadius(rad);
        return done;
    }
    else {
        return false;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
float PyCharacterController::get_height(CharControlComponent * c) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        return std::static_pointer_cast<CapsuleController>(c->controller())->getHeight();
    }
    else {
        return std::static_pointer_cast<BoxController>(c->controller())->getHalfHeight() * 2.0f;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyCharacterController::set_height(CharControlComponent * c, float height) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        bool done = std::static_pointer_cast<CapsuleController>(c->controller())->setHeight(height);
        return done;
    }
    else {
        return std::static_pointer_cast<BoxController>(c->controller())->setHalfHeight(height / 2.0f);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::set_height_offset(CharControlComponent * c, float offset) const
{
    c->controller()->setHeightOffset(offset);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::set_initial_position(CharControlComponent * c, const Vector3* pos) const
{
    // TODO: Use floats on python side
    c->controller()->setInitialPosition(pos->asReal());
}
/////////////////////////////////////////////////////////////////////////////////////////////
CharControlComponent* PyCharacterController::new_CharControlComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    CharControlComponent* c = new CharControlComponent(objectShared);
    c->setIsPythonGenerated(true);
    return c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::delete_CharControlComponent(CharControlComponent * c)
{
    delete c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyCharacterController::as_json_str(CharControlComponent * c) const
{
    QString strJson = JsonReader::ToQString(c->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyCharacterController::scene_object(CharControlComponent * c) const
{
    return c->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyCharacterController::py_toString(CharControlComponent * c)
{
    return c->asQString();
}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyTransformComponent
/////////////////////////////////////////////////////////////////////////////////////////////
PyTransformComponent::PyTransformComponent() {

}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyTransformComponent::as_json_str(TransformComponent * t) const
{
    QString strJson = JsonReader::ToQString(t->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent * PyTransformComponent::translation(TransformComponent * t)
{
    return &(t->translation());
}
/////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent * PyTransformComponent::rotation(TransformComponent * r)
{
    return &(r->rotation());
}
/////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent * PyTransformComponent::scale(TransformComponent * s)
{
    return &(s->scale());
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyTransformComponent::scene_object(TransformComponent * t) const
{
    return t->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyTransformComponent::py_toString(TransformComponent * t)
{
    return t->Object::asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
const Vector3 * PyTransformComponent::local_pos(TransformComponent * t) const
{
    return &t->getPosition();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyTransformComponent::pos(TransformComponent * t) const
{
    const Vector4& column = t->worldMatrix().getColumn(3);
    return new Vector3(column[0], column[1], column[2]);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTransformComponent::set_local_pos(TransformComponent * t, Vector3* pos) const
{
    t->translation().setPosition(*pos);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTransformComponent::set_pos(TransformComponent * t, Vector3 * pos) const
{
    t->setWorldPosition(*pos);
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyTranslationComponent
/////////////////////////////////////////////////////////////////////////////////////////////
PyTranslationComponent::PyTranslationComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyTranslationComponent::as_json_str(TranslationComponent * t) const
{
    QString strJson = JsonReader::ToQString(t->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
const Vector3* PyTranslationComponent::local_pos(TranslationComponent * t) const
{
    return &(t->getPosition());
    //return PythonAPI::get()->toPyTuple(t->getPosition().asStdVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTranslationComponent::set_local_pos(TranslationComponent * t, Vector3 * pos)
{
    t->setPosition(*pos);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTranslationComponent::set_local_pos(TranslationComponent* t, PyObject* position)
{
    // See: https://sourceforge.net/p/pythonqt/discussion/631393/thread/cf43961596/?limit=25#04ef
    // But yes, you can do a type check for PythonQt
    // wrappers and get the wrapped ptr from a wrapper.There is no example, but
    // you can see it in PythonQtConversion and PythonQtClassInfo how to do this.
    if (PythonAPI::get()->isListLike(position)) {
        std::vector<real_g> pVec = PythonAPI::get()->toVec<real_g>(position);
        t->setPosition(pVec);

    }
    else {
        //QString className = PythonAPI::get()->getClassName(position);
#ifdef DEBUG_MODE
        throw("Error, position type not recognized");
#endif
        QString stdErr = PythonAPI::get()->printAndClearErrors();
        //logError("set_local_pos:: Error, position type " + className + " not recognized: " + stdErr);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////
//const Vector3g * PyTranslationComponent::get_velocity(TranslationComponent * t) const
//{
//    return &(t->getVelocity());
//    //return PythonAPI::get()->toPyTuple(t->getVelocity().asStdVector());
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_velocity(TranslationComponent * t, Vector3g * vel)
//{
//    t->setVelocity(*vel);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_velocity(TranslationComponent* t, PyObject* vel)
//{
//    std::vector<double> vVec = PythonAPI::get()->toVecDouble(vel);
//    t->setVelocity(vVec);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//const Vector3g * PyTranslationComponent::get_acceleration(TranslationComponent * t) const
//{
//    return &(t->getAcceleration());
//    //return PythonAPI::get()->toPyTuple(t->getAcceleration().asStdVector());
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_acceleration(TranslationComponent * t, Vector3g * acc)
//{
//    t->setAcceleration(*acc);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_acceleration(TranslationComponent* t, PyObject* acc)
//{
//    std::vector<double> aVec = PythonAPI::get()->toVecDouble(acc);
//    t->setAcceleration(aVec);
//}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyTranslationComponent::py_toString(TranslationComponent * t)
{
    return t->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Quaternion
/////////////////////////////////////////////////////////////////////////////////////////////
PyQuaternion::PyQuaternion() {

}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion* PyQuaternion::new_Quaternion() {
    return new Quaternion();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion* PyQuaternion::new_Quaternion(double x, double y, double z, double w) {
    return new Quaternion(x, y, z, w);
}
/////////////////////////////////////////////////////////////////////////////////////////////
//Quaternion * PyQuaternion::new_Quaternion(double roll, double pitch, double yaw)
//{
//    return new Quaternion(roll, pitch, yaw);
//}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_look_rotation(const Vector3* dir, const Vector3* up)
{
    return new Quaternion(Quaternion::fromDirection(*dir, *up));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_slerp(const Quaternion * q1, const Quaternion * q2, double factor)
{
    return new Quaternion(std::move(Quaternion::Slerp(*q1, *q2, factor)));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_axis_angle(const Vector3 * axis, double angle)
{
    return new Quaternion(Quaternion::fromAxisAngle(*axis, angle));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_euler_angles(double a1, double a2, double a3)
{
    return new Quaternion(Quaternion::fromEulerAngles(EulerAngles(a1, a2, a3, EulerAngles::kZYX, RotationSpace::kInertial)));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_euler_angles(const EulerAngles * angles)
{
    return new Quaternion(Quaternion::fromEulerAngles(*angles));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_rotation_matrix(const Matrix3x3d * mat)
{
    return new Quaternion(Quaternion::fromRotationMatrix(*mat));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_rotation_matrix(const Matrix4x4d * mat)
{
    return new Quaternion(Quaternion::fromRotationMatrix(*mat));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_from_direction(const Vector3 * dir, const Vector3 * up)
{
    return new Quaternion(Quaternion::fromDirection(*dir, *up));
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyQuaternion::delete_Quaternion(Quaternion * q)
{
    delete q;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyQuaternion::py_toString(Quaternion * q)
{
    QJsonArray arr = q->asJson().toArray();
    QJsonDocument doc(arr);
    QString strJson(doc.toJson(QJsonDocument::Compact));
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyQuaternion::__eq__(Quaternion * q, Quaternion* q2)
{
    return *q == *q2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__add__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion((*q) + *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__sub__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion(*q - *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__mul__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion((*q) * (*q2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyQuaternion::__mul__(Quaternion * q, Vector3 * v)
{
    return new Vector3((*q) * (*v));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__iadd__(Quaternion * q, Quaternion* q2)
{
    return &(*q += *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__isub__(Quaternion * q, Quaternion* q2)
{
    return &(*q -= *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__imul__(Quaternion * q, Quaternion* q2)
{
    return &(*q *= *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
int PyQuaternion::norm(Quaternion * q) const
{
    return q->length();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyQuaternion::normalize(Quaternion * q) const
{
    q->normalize();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Quaternion
/////////////////////////////////////////////////////////////////////////////////////////////
PyEulerAngles::PyEulerAngles() {

}
///////////////////////////////////////////////////////////////////////////////////////////
EulerAngles * PyEulerAngles::new_EulerAngles(float ax, float ay, float az, PyObject* rotationOrder, int rotationType)
{
    EulerAngles::Axes axes = toAxes(rotationOrder);
    return new EulerAngles(ax, ay, az, axes, RotationSpace(rotationType));
}
/////////////////////////////////////////////////////////////////////////////////////////////
EulerAngles::Axes PyEulerAngles::toAxes(PyObject * o)
{
    std::vector<int> vec = PythonAPI::get()->toVec<int>(o);
    EulerAngles::Axes axes;
    for (size_t i = 0; i < vec.size(); i++) {
        axes[i] = Axis(vec[i]);
    }
    return axes;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyEulerAngles::delete_EulerAngles(EulerAngles * q)
{
    delete q;
}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Rotation Component
/////////////////////////////////////////////////////////////////////////////////////////////
PyRotationComponent::PyRotationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::add_rotation(RotationComponent* r, const EulerAngles& eulerAngles)
{
    return r->addRotation(eulerAngles);
}
///////////////////////////////////////////////////////////////////////////////////////////
const Quaternion * PyRotationComponent::quaternion(RotationComponent * r) const
{
    return &r->getQuaternion();
}
///////////////////////////////////////////////////////////////////////////////////////////
const Quaternion * PyRotationComponent::get_quaternion(RotationComponent * r) const
{
    return &r->getQuaternion();
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::set(RotationComponent * r, Quaternion * quaternion)
{
    return r->setRotation(*quaternion);
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::set_rotation(RotationComponent* r, Quaternion * quaternion)
{
    return r->setRotation(*quaternion);
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::set_rotation(RotationComponent* r, const EulerAngles& eulerAngles)
{
    return r->setRotation(eulerAngles);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyRotationComponent::as_json_str(RotationComponent * r) const
{
    QString strJson = JsonReader::ToQString(r->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyRotationComponent::py_toString(RotationComponent * r)
{
    return r->asQString();
}





/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Scale Component
/////////////////////////////////////////////////////////////////////////////////////////////
PyScaleComponent::PyScaleComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject* PyScaleComponent::get_scale(ScaleComponent* s) const
{
    PyObject* scale = PythonAPI::get()->toPyTuple(s->getScale());
    return scale;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent * s, Vector3 * scale)
{
    s->setScale(*scale);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent* s, PyObject * scale)
{
    s->setScale(PythonAPI::get()->toVec<real_g>(scale));
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent* s, double x, double y, double z)
{
    s->setScale(x, y, z);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyScaleComponent::as_json_str(ScaleComponent * s) const
{
    QString strJson = JsonReader::ToQString(s->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyScaleComponent::py_toString(ScaleComponent * s)
{
    return s->asQString();
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Audio Component
/////////////////////////////////////////////////////////////////////////////////////////////
PyAudioComponent::PyAudioComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyAudioComponent::play(AudioSourceComponent * ac)
{
    ac->queuePlay();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyAudioComponent::py_toString(AudioSourceComponent * ac)
{
    return ac->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyAudioComponent::as_json_str(AudioSourceComponent* ac) const
{
    QString strJson = JsonReader::ToQString(ac->asJson());
    return strJson;
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Input handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyInputHandler::PyInputHandler()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
KeyHandler * PyInputHandler::key_handler(InputHandler * ih)
{
    return &(ih->keyHandler());
}
/////////////////////////////////////////////////////////////////////////////////////////////
MouseHandler * PyInputHandler::mouse_handler(InputHandler * ih)
{
    return &(ih->mouseHandler());
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyInputHandler::py_toString(InputHandler * ih)
{
    return ih->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Key handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyKeyHandler::PyKeyHandler()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////
QString PyKeyHandler::py_toString(KeyHandler * ih)
{
    return ih->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_pressed(KeyHandler* kh, int key)
{
    return kh->wasPressed(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_pressed(KeyHandler* kh, const QString & key)
{
    return kh->wasPressed(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_released(KeyHandler* kh, int key)
{
    return kh->wasReleased(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_released(KeyHandler* kh, const QString & key)
{
    return kh->wasReleased(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_double_clicked(KeyHandler* kh, int key)
{
    return kh->wasDoubleClicked(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_double_clicked(KeyHandler* kh, const QString & key)
{
    return kh->wasDoubleClicked(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::is_held(KeyHandler* kh, int key) const
{
    return kh->isHeld(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::is_held(KeyHandler* kh, const QString & key)
{
    return kh->isHeld(key);
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Mouse handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyMouseHandler::PyMouseHandler()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyMouseHandler::py_toString(MouseHandler * ih)
{
    return ih->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_pressed(MouseHandler* mh, int btn)
{
    return mh->wasPressed(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_released(MouseHandler* mh, int btn)
{
    return mh->wasReleased(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_double_clicked(MouseHandler* mh, int btn)
{
    return mh->wasDoubleClicked(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::is_held(MouseHandler* mh, int btn)
{
    return mh->isHeld(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::moved(MouseHandler * mh)
{
    return mh->wasMoved();
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::scrolled(MouseHandler * mh)
{
    return mh->wasScrolled();
}
/////////////////////////////////////////////////////////////////////////////////////////////
const Vector2 * PyMouseHandler::mouse_delta(MouseHandler * m)
{
    return &(m->mouseDelta());
    //return new Vector2(m->mouseDelta());
}
/////////////////////////////////////////////////////////////////////////////////////////////
const Vector2* PyMouseHandler::scroll_delta(MouseHandler * m)
{
    return &(m->scrollDelta());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyMouseHandler::screen_pos(MouseHandler * mh)
{
    Vector2 pos = mh->normalizeMousePosition();
    return new Vector3(pos[0], pos[1], 0.0);
}


/////////////////////////////////////////////////////////////////////////////////////////////
} // End namespaces

