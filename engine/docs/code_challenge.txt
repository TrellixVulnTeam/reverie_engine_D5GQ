/*
 * Complete the function below.
 
 https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
 */

bool LaserHitsAsteroid( float laserStart[3], float laserDir[3], float asteroidPos[3], float asteroidRadius )
{
    // Get distance from ray to asteroid origin
    std::array<double, 3> laserToAsteroid;
    dist(asteroidPos, laserStart, laserToAsteroid);
    double L = length(laserToAsteroid.data());

    // If laser is within or on sphere, then it intersects
    if(L <= asteroidRadius) return true;

    // Normalize direction vector
    std::array<double, 3> normDir;
    norm(laserDir, normDir);

    // First check for intersection using dot-product for projection
    double distDotDir = dot(laserToAsteroid.data(), normDir.data());
    if(distDotDir < 0) 
        return false; // No hit if dot product negative

    // Determine last side of intersection triangle
    double d2 = L * L - distDotDir * distDotDir;
    double asteroidRadius2 = double(asteroidRadius) * double(asteroidRadius);
    if((d2 - asteroidRadius2) > 1e-12) // A simple comparison runs into precision issues
        return false;
    else 
        return true;
}


/*
number 2
*/
int toInt(const char& c){
    return int(c - '0');
}

int addChar(const char& x, const char& y){
    return toInt(x) + toInt(y);
}

char toChar(int x){
    if(x > 9) throw("Error, integer is too large for char conversion");
    return char('0' + x);
}

size_t getCharArrayLength(const char* X){
    size_t len = 0;
    const char* x = &X[0];
    while (*x != '\0'){
        x = &X[len];
        len++;
    }
    return len - 1; // Don't include null character in length
}

char* AddAsciiIntegers( const char* X, const char* Y)
{
    // Determine lengths of input arrays and determine the larger size
    size_t lenX = getCharArrayLength(X);
    size_t lenY = getCharArrayLength(Y);
    size_t numIter = std::min(lenX, lenY);
    size_t smallerSize = std::min(lenX, lenY);
    size_t biggerSize  = std::max(lenX, lenY);
    
    // Initialize output char array from the larger input
    size_t charSize = biggerSize + 1;
    char* outChars = new char[charSize];
    outChars[0] = '0';
    const char* bigger  = lenX > lenY? X: Y;
    const char* smaller = lenX > lenY? Y: X;
    for(size_t i = 0; i < biggerSize; i++){
        outChars[i+1] = bigger[i];
    }
    
    // Iterate from least to most significant digits of input char arrays
    int sum;
    int currentOutIndex;
    const char* s;
    for (size_t i=1; i <= numIter; i++){
        s = &smaller[smallerSize - i];
        
        currentOutIndex = charSize - i;
        sum = addChar(outChars[currentOutIndex], *s);
        outChars[currentOutIndex] = toChar(sum % 10);
        
        int additionOffset = 1;
        int nextAdditionIndex;
        int remainder = sum / 10;
        
        // Propagate addition of remainder leftwards until there is none remaining
        while(remainder > 0){
            nextAdditionIndex = currentOutIndex - additionOffset;

            sum = toInt(outChars[nextAdditionIndex]) + remainder;
            outChars[nextAdditionIndex] = toChar((sum % 10));
            remainder = sum / 10;
            
            additionOffset++;
        }
    }
    
    return outChars;
}

/*
Figure out how many letters are needed to construct the word
*/
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <assert.h>

using namespace std;


int toInt(const char& c){
    return int(c - '0');
}

int addChar(const char& x, const char& y){
    return toInt(x) + toInt(y);
}

char toChar(int x){
    if(x > 9) throw("Error, integer is too large for char conversion");
    return char('0' + x);
}

/*
 * Complete the function below.
 */
int LettersNeededForChurchSign( const char* sentence, const char* lettersAvailable )
{
    // Sort the characters in the sentence, while removing white space
    size_t sentenceSize = strlen(sentence);
    std::vector<char> sentenceVec;
    sentenceVec.reserve(sentenceSize);
    for(size_t i = 0; i < sentenceSize; i++){
        const char& c = sentence[i];
        if(isspace(c)) continue;
        sentenceVec.push_back(c);
    }
    std::sort(sentenceVec.begin(), sentenceVec.end(), std::less<char>());

    // Sort the characters in the letter pile, while removing white space and character not in the sentence
    size_t pileSize = strlen(lettersAvailable);
    std::vector<char> pileVec;
    pileVec.reserve(pileSize);
    for(size_t i = 0; i < pileSize; i++){
        const char& c = lettersAvailable[i];
        if(isspace(c)) continue;
        if(!strchr(sentence, c)) continue;
        pileVec.push_back(c);
    }
    std::sort(pileVec.begin(), pileVec.end(), std::less<char>());

    int count = 0;
    int sentenceIndex = 0;
    int foundIndex;
    int remainingSentenceLength;
    const char* pileLetter;
    for(size_t i=0; i < pileVec.size(); i++){
        char pileLetter = pileVec.at(i);

        foundIndex = strcspn(&sentenceVec[sentenceIndex], &pileLetter); // span until an entry of second string found in first str
        remainingSentenceLength = sentenceVec.size() - sentenceIndex; 

        if(foundIndex < remainingSentenceLength){  
            // Letter is in sentence
            sentenceIndex += foundIndex + 1;
            count++;
        }else{
            // Pile letter not in sentence
        }

    }
    count = sentenceVec.size() - count;
    return count;
}

// Alternatively
int LettersNeededForChurchSign( const char* sentence, const char* lettersAvailable )
{
    // Sort the characters in the sentence, while removing white space
    size_t sentenceSize = strlen(sentence);
    std::vector<char> sentenceVec;
    sentenceVec.reserve(sentenceSize);
    for(size_t i = 0; i < sentenceSize; i++){
        const char& c = sentence[i];
        if(isspace(c)) continue;
        sentenceVec.push_back(c);
    }
    std::sort(sentenceVec.begin(), sentenceVec.end(), std::less<char>());

    // Sort the characters in the letter pile, while removing white space and character not in the sentence
    size_t pileSize = strlen(lettersAvailable);
    std::vector<char> pileVec;
    pileVec.reserve(pileSize);
    for(size_t i = 0; i < pileSize; i++){
        const char& c = lettersAvailable[i];
        if(isspace(c)) continue;
        if(!strchr(sentence, c)) continue;
        pileVec.push_back(c);
    }
    std::sort(pileVec.begin(), pileVec.end(), std::less<char>());


    size_t count = 0;
    char* foundChar = &sentenceVec[0];
    size_t currentIndex = 0;
    for(size_t i=0; i < pileVec.size(); i++){
        char pileLetter = pileVec.at(i);
        foundChar = strchr(&sentenceVec[currentIndex], (int)pileLetter); // span until an entry of second string found in first str

        if(foundChar){  
            // Letter is in sentence
            count++;

            currentIndex = foundChar - &sentenceVec[0] + 1;
            if(currentIndex >= sentenceVec.size()){
                break;
            }
        }
    }
    count = sentenceVec.size() - count;
    return count;
}


/* Pathfinding */

struct PathNode
{
    float pos[2]; // required
    bool isSpawner; // required
    
    // Add additional fields here if needed.
    PathNode* m_leftChild; // The child of this node with a lower value
    PathNode* m_rightChild; // The child of this node with a higher value 
};

size_t getAxisMedian(std::vector<PathNode*>& nodes, size_t axis){
    // Could optimize this by doing a sort over a subset of the original set of nodes
    // Sort list of nodes by the given axis
    std::sort(nodes.begin(), nodes.end(), [&](PathNode* node1, PathNode* node2){
        return node1->pos[axis] < node2->pos[axis];
    });

    // Return the index of the median entry
    return floor(nodes.size() / 2.0);
}

template<size_t K>
void kdTree(int nodeCount, PathNode* nodes, std::vector<PathNode*>& outSpawners){
    if(!nodes) return;
    if(nodeCount == 0) return;

    // Create input vector
    std::vector<PathNode*> nodeVec;
    for(size_t i=0; i < nodeCount; i++){
        nodeVec.push_back(&nodes[i]);
    }
    kdTree<K>(nodeVec, outSpawners, 0);
}

template<size_t K>
PathNode* kdTree(std::vector<PathNode*>& nodes, std::vector<PathNode*>& outSpawners, size_t depth){
    if(nodes.size() == 0) return nullptr;

    // Select axis of the kd-tree, based on the current depth
    size_t axis = depth % K;

    // Obtain the median along the current axis from the list of nodes
    size_t medianIndex = getAxisMedian(nodes, axis);
    PathNode* median;
    median = nodes[medianIndex];
    if(median->isSpawner) outSpawners.push_back(median);

    // Construct subtrees
    std::vector<PathNode*> leftNodes(nodes.begin(), nodes.begin() + medianIndex); // [begin, end)
    std::vector<PathNode*> rightNodes(nodes.begin() + medianIndex + 1, nodes.end()); // need to add 1 to avoid including median
    median->m_leftChild  = kdTree<K>(leftNodes, outSpawners, depth + 1);
    median->m_rightChild = kdTree<K>(rightNodes, outSpawners, depth + 1);

    return median;
}

void findValidIndices(const std::vector<PathNode*>& outSpawners, std::vector<int>& validIndices){
    // Traverse the tree for valid indices
    for(PathNode* node: outSpawners){
        // Start at each spawn node, and traverse until distance is too great
    }
}


/*
 * Complete the function below.
 */
int* GetReachableNodes( int nodeCount, PathNode* nodes, int* resultIndexCount )
{
    // Construct kdtree for nodes
    std::vector<PathNode*> outSpawners;
    kdTree<2>(nodeCount, nodes, outSpawners);
    for(const auto& node: outSpawners){
        cout << node->pos[0] << ", " << node->pos[1] << '\n';
    }

    // Traverse tree for reachable nodes
    std::vector<int> validIndices;
    findValidIndices(outSpawners, validIndices);
    return validIndices.data();
}