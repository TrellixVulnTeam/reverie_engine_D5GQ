#include "GbPyWrappers.h"
#include <QJsonDocument>


#include "GbPythonAPI.h"
#include "../GbCoreEngine.h"
#include "../../view/GbWidgetManager.h"
#include "../../view/GL/GbGLWidget.h"

#include "../events/GbEvent.h"

#include "../components/GbLight.h"
#include "../components/GbCamera.h"
#include "../components/GbRendererComponent.h"
#include "../components/GbTransformComponent.h"
#include "../components/GbPhysicsComponents.h"
#include "..//physics/GbCharacterController.h"
#include "../rendering/view/GbRenderProjection.h"
#include "../rendering/renderer/GbRenderers.h"
#include "../rendering/shaders/GbShaders.h"

#include "../resource/GbResourceCache.h"
#include "../scene/GbScenario.h"
#include "../scene/GbScene.h"
#include "../scene/GbSceneObject.h"
#include "../input/GbInputHandler.h"
#include "../geometry/GbTransformComponents.h"
#include "../geometry/GbEulerAngles.h"
#include "../readers/GbJsonReader.h"

namespace Gb {

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyEngine
/////////////////////////////////////////////////////////////////////////////////////////////
PyEngine::PyEngine()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Scenario* PyEngine::scenario(CoreEngine* e) const {
    return e->scenario().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
InputHandler * PyEngine::input_handler(CoreEngine* e) const
{
    return &(e->widgetManager()->mainGLWidget()->inputHandler());
}
/////////////////////////////////////////////////////////////////////////////////////////////
ResourceCache * PyEngine::resource_cache(CoreEngine * e) const
{
    return e->resourceCache();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyEngine::py_toString(CoreEngine * e)
{
    return e->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyCustomEvent
/////////////////////////////////////////////////////////////////////////////////////////////
PyCustomEvent::PyCustomEvent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyCustomEvent::as_json_str(CustomEvent * e) const
{
    QString strJson = JsonReader::getJsonValueAsQString(e->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
int PyCustomEvent::type(CustomEvent * e) const
{
    return e->type();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QVariantMap PyCustomEvent::dataMap(CustomEvent * e) const
{
    return e->data().toVariantMap();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyCustomEvent::py_toString(CustomEvent * e)
{
    QString strJson = JsonReader::getJsonValueAsQString(e->asJson());
    return strJson;
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyResourceCache
/////////////////////////////////////////////////////////////////////////////////////////////
PyResourceCache::PyResourceCache()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
const ShaderProgram* PyResourceCache::get_shader(ResourceCache* r, const QString& name) const {
    return r->getShaderProgramByName(name).get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyResourceCache::as_json_str(ResourceCache * r) const
{
    QString strJson = JsonReader::getJsonValueAsQString(r->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyResourceCache::py_toString(ResourceCache * r)
{
    return r->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyVector2
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
PyVector2::PyVector2()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::new_Vector2()
{
    return new Vector2();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::new_Vector2(double v1, double v2)
{
    return new Vector2(v1, v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::new_Vector2(Vector2 * o)
{
    return new Vector2(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::new_Vector2(PyObject * o)
{
    std::vector<double> vec = PythonAPI::get()->toVecDouble(o);
    return new Vector2(vec);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector2::delete_Vector2(Vector2 * v)
{
    delete v;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyVector2::py_toString(Vector2 * v)
{
    return QString(*v);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyVector2::__eq__(Vector2 * v, Vector2* v2)
{
    return *v == *v2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2* PyVector2::__add__(Vector2 * v, Vector2* v2)
{
    return new Vector2((*v) + *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__add__(Vector2 * v, double f)
{
    return new Vector2((*v) + f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__add__(Vector2 * v, int f)
{
    return new Vector2((*v) + f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__add__(Vector2 * v, PyObject * p2)
{
    Vector2 v2 = Vector2(PythonAPI::get()->toVecDouble(p2));
    return new Vector2((*v) + v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2* PyVector2::__sub__(Vector2 * v, Vector2* v2)
{
    return new Vector2((*v) - *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__sub__(Vector2 * v, PyObject * p2)
{
    Vector2 v2 = Vector2(PythonAPI::get()->toVecDouble(p2));
    return new Vector2((*v) - v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2* PyVector2::__mul__(Vector2 * v, Vector2* v2)
{
    return new Vector2((*v) * (*v2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__mul__(Vector2 * v, double f)
{
    return new Vector2(*v * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__mul__(Vector2 * v, int f)
{
    return new Vector2(*v * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__mul__(Vector2 * v, PyObject* o)
{
    //QString type = PythonAPI::get()->getClassName(o);
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector
        Vector2 v2 = Vector2(PythonAPI::get()->toVecDouble(o));
        return new Vector2((*v) * v2);
    }
    else {
        // If multiplying by a value
        return new Vector2(*v * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2* PyVector2::__iadd__(Vector2 * v, Vector2* v2)
{
    return &(*v += *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__isub__(Vector2 * v, Vector2* v2)
{
    return &(*v -= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::__imul__(Vector2 * v, Vector2* v2)
{
    return &(*v *= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyVector2::dot(Vector2 * v1, Vector2 * v2)
{
    return v1->dot(*v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyVector2::to_list(Vector2* v) const
{
    return PythonAPI::get()->toPyTuple(v->asStdVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyVector2::normalized(Vector2 * v) const
{
    return new Vector2(v->normalized());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector2::normalize(Vector2 * v) const
{
    v->normalize();
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyVector2::length(Vector2 * v) const
{
    return v->length();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyVector3
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
PyVector3::PyVector3()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::new_Vector3()
{
    return new Vector3();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::new_Vector3(double v1, double v2, double v3)
{
    return new Vector3(v1, v2, v3);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::new_Vector3(Vector3 * o)
{
    return new Vector3(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::new_Vector3(PyObject * o)
{
    std::vector<double> vec = PythonAPI::get()->toVecDouble(o);
    return new Vector3(vec);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector3::delete_Vector3(Vector3 * v)
{
    delete v;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyVector3::py_toString(Vector3 * v)
{
    return QString(*v);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyVector3::__eq__(Vector3 * v, Vector3* v2)
{
    return *v == *v2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3* PyVector3::__add__(Vector3 * v, Vector3* v2)
{
    return new Vector3((*v) + *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__add__(Vector3 * v, double f)
{
    return new Vector3((*v) + f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__add__(Vector3 * v, int f)
{
    return new Vector3((*v) + f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__add__(Vector3 * v, PyObject * p2)
{
    Vector3 v2 =  Vector3(PythonAPI::get()->toVecDouble(p2));
    return new Vector3((*v) + v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3* PyVector3::__sub__(Vector3 * v, Vector3* v2)
{
    return new Vector3((*v) - *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__sub__(Vector3 * v, PyObject * p2)
{
    Vector3 v2 = Vector3(PythonAPI::get()->toVecDouble(p2));
    return new Vector3((*v) - v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3* PyVector3::__mul__(Vector3 * v, Vector3* v2)
{
    return new Vector3((*v) * (*v2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__mul__(Vector3 * v, double f)
{
    return new Vector3(*v * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__mul__(Vector3 * v, int f)
{
    return new Vector3(*v * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__mul__(Vector3 * v, PyObject* o)
{
    //QString type = PythonAPI::get()->getClassName(o);
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector
        Vector3 v2 = Vector3(PythonAPI::get()->toVecDouble(o));
        return new Vector3((*v) * v2);
    }
    else {
        // If multiplying by a value
        return new Vector3(*v * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3* PyVector3::__iadd__(Vector3 * v, Vector3* v2)
{
    return &(*v += *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__isub__(Vector3 * v, Vector3* v2)
{
    return &(*v -= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::__imul__(Vector3 * v, Vector3* v2)
{
    return &(*v *= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3* PyVector3::cross(Vector3 * v1, Vector3 * v2)
{
    Vector3 crossP = v1->cross(*v2);
    return new Vector3(crossP);
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyVector3::dot(Vector3 * v1, Vector3 * v2)
{
    return v1->dot(*v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyVector3::to_list(Vector3* v) const
{
    return PythonAPI::get()->toPyTuple(v->asStdVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyVector3::normalized(Vector3 * v) const
{
    return new Vector3(v->normalized());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector3::normalize(Vector3 * v) const
{
    v->normalize();
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyVector3::length(Vector3 * v) const
{
    return v->length();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyVector4
/////////////////////////////////////////////////////////////////////////////////////////////
PyVector4::PyVector4()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::new_Vector4()
{
    return new Vector4();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::new_Vector4(double v1, double v2, double v3, double v4)
{
    return new Vector4(v1, v2, v3, v4);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::new_Vector4(Vector4 * o)
{
    return new Vector4(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::new_Vector4(PyObject * o)
{
    std::vector<double> vec = PythonAPI::get()->toVecDouble(o);
    return new Vector4(vec);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector4::delete_Vector4(Vector4 * v)
{
    delete v;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyVector4::py_toString(Vector4 * e)
{
    return QString(*e);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyVector4::__eq__(Vector4 * v, Vector4* v2)
{
    return *v == *v2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4* PyVector4::__add__(Vector4 * v, Vector4* v2)
{
    return new Vector4((*v) + *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__add__(Vector4 * v, PyObject * p2)
{
    Vector4 v2 = Vector4(PythonAPI::get()->toVecDouble(p2));
    return new Vector4((*v) + v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4* PyVector4::__sub__(Vector4 * v, Vector4* v2)
{
    return new Vector4((*v) - *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__sub__(Vector4 * v, PyObject * p2)
{
    Vector4 v2 = Vector4(PythonAPI::get()->toVecDouble(p2));
    return new Vector4((*v) - v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4* PyVector4::__mul__(Vector4 * v, Vector4* v2)
{
    return new Vector4((*v) * (*v2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__mul__(Vector4 * v, double f)
{
    return new Vector4(*v * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__mul__(Vector4 * v, int f)
{
    return new Vector4(*v * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__mul__(Vector4 * v, PyObject* o)
{
    //QString type = PythonAPI::get()->getClassName(o);
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector
        Vector4 v2 = Vector4(PythonAPI::get()->toVecDouble(o));
        return new Vector4((*v) * v2);
    }
    else {
        // If multiplying by a value
        return new Vector4(*v * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4* PyVector4::__iadd__(Vector4 * v, Vector4* v2)
{
    return &(*v += *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__isub__(Vector4 * v, Vector4* v2)
{
    return &(*v -= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::__imul__(Vector4 * v, Vector4* v2)
{
    return &(*v *= *v2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyVector4::to_list(Vector4* v) const
{
    return PythonAPI::get()->toPyTuple(v->asStdVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyVector4::normalized(Vector4 * v) const
{
    return new Vector4(v->normalized());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyVector4::normalize(Vector4 * v) const
{
    v->normalize();
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyVector4::length(Vector4 * v) const
{
    return v->length();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyMatrix2x2
/////////////////////////////////////////////////////////////////////////////////////////////
PyMatrix2x2::PyMatrix2x2()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::new_Matrix2x2()
{
    return new Matrix2x2();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::new_Matrix2x2(Matrix2x2 * o)
{
    return new Matrix2x2(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::new_Matrix2x2(PyObject * o)
{
    std::vector<std::vector<double>> vecs = PythonAPI::get()->toVecOfVecDouble(o);
    return new Matrix2x2(vecs);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix2x2::delete_Matrix2x2(Matrix2x2 * m)
{
    delete m;
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix2x2::at(Matrix2x2 * m, int row, int col)
{
    return m->at(row, col);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyMatrix2x2::column(Matrix2x2 * m, int idx)
{
    return new Vector2(m->getColumn(idx));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::transposed(Matrix2x2 * m)
{
    return new Matrix2x2(m->transposed());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix2x2::set_to_identity(Matrix2x2 * m)
{
    m->setToIdentity();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector2 * PyMatrix2x2::diagonal(Matrix2x2 * m)
{
    return new Vector2(m->diagonal());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::transpose_multiply(Matrix2x2 * m, Matrix2x2 * m2)
{
    return new Matrix2x2(m->transposeMultiply(*m2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix2x2::determinant(Matrix2x2 * m)
{
    return m->determinant();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::inversed(Matrix2x2 * m)
{
    return new Matrix2x2(std::move(m->inversed()));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMatrix2x2::__eq__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return *m == *m2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__add__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return new Matrix2x2((*m) + *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__add__(Matrix2x2 * m, PyObject * p2)
{
    Matrix2x2 m2 = Matrix2x2(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix2x2((*m) + m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__sub__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return new Matrix2x2((*m) - *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__sub__(Matrix2x2 * m, PyObject * p2)
{
    Matrix2x2 m2 = Matrix2x2(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix2x2((*m) - m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__mul__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return new Matrix2x2((*m) * (*m2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__mul__(Matrix2x2 * m, double f)
{
    return new Matrix2x2((*m) * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__mul__(Matrix2x2 * m, int f)
{
    return new Matrix2x2((*m) * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__mul__(Matrix2x2 * m, PyObject * o)
{
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector of vectors
        Matrix2x2 m2 = Matrix2x2(PythonAPI::get()->toVecOfVecDouble(o));
        return new Matrix2x2((*m) * m2);
    }
    else {
        // If multiplying by a value
        return new Matrix2x2(*m * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__iadd__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__isub__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix2x2 * PyMatrix2x2::__imul__(Matrix2x2 * m, Matrix2x2 * m2)
{
    return &(*m -= *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyMatrix2x2::to_list(Matrix2x2 * m) const
{
    return PythonAPI::get()->toPyTuple(m->asStdVector());

}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyMatrix2x2::py_toString(Matrix2x2 * m)
{
    return QString(*m);
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyMatrix3x3
/////////////////////////////////////////////////////////////////////////////////////////////
PyMatrix3x3::PyMatrix3x3()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::new_Matrix3x3()
{
    return new Matrix3x3();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::new_Matrix3x3(Matrix3x3 * o)
{
    return new Matrix3x3(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::new_Matrix3x3(PyObject * o)
{
    std::vector<std::vector<double>> vecs = PythonAPI::get()->toVecOfVecDouble(o);
    return new Matrix3x3(vecs);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix3x3::delete_Matrix3x3(Matrix3x3 * m)
{
    delete m;
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix3x3::at(Matrix3x3 * m, int row, int col)
{
    return m->at(row, col);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyMatrix3x3::column(Matrix3x3 * m, int idx)
{
    return new Vector3(m->getColumn(idx));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::transposed(Matrix3x3 * m)
{
    return new Matrix3x3(m->transposed());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix3x3::set_to_identity(Matrix3x3 * m)
{
    m->setToIdentity();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyMatrix3x3::diagonal(Matrix3x3 * m)
{
    return new Vector3(m->diagonal());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::transpose_multiply(Matrix3x3 * m, Matrix3x3 * m2)
{
    return new Matrix3x3(m->transposeMultiply(*m2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix3x3::determinant(Matrix3x3 * m)
{
    return m->determinant();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::inversed(Matrix3x3 * m)
{
    return new Matrix3x3(std::move(m->inversed()));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMatrix3x3::__eq__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return *m == *m2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__add__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return new Matrix3x3((*m) + *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__add__(Matrix3x3 * m, PyObject * p2)
{
    Matrix3x3 m2 = Matrix3x3(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix3x3((*m) + m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__sub__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return new Matrix3x3((*m) - *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__sub__(Matrix3x3 * m, PyObject * p2)
{
    Matrix3x3 m2 = Matrix3x3(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix3x3((*m) - m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__mul__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return new Matrix3x3((*m) * (*m2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__mul__(Matrix3x3 * m, double f)
{
    return new Matrix3x3((*m) * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__mul__(Matrix3x3 * m, int f)
{
    return new Matrix3x3((*m) * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__mul__(Matrix3x3 * m, PyObject * o)
{
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector of vectors
        Matrix3x3 m2 = Matrix3x3(PythonAPI::get()->toVecOfVecDouble(o));
        return new Matrix3x3((*m) * m2);
    }
    else {
        // If multiplying by a value
        return new Matrix3x3(*m * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__iadd__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__isub__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix3x3 * PyMatrix3x3::__imul__(Matrix3x3 * m, Matrix3x3 * m2)
{
    return &(*m -= *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyMatrix3x3::to_list(Matrix3x3 * m) const
{
    return PythonAPI::get()->toPyTuple(m->asStdVector());

}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyMatrix3x3::py_toString(Matrix3x3 * m)
{
    return QString(*m);
}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyMatrix4x4
/////////////////////////////////////////////////////////////////////////////////////////////
PyMatrix4x4::PyMatrix4x4() {

}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::new_Matrix4x4()
{
    return new Matrix4x4();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::new_Matrix4x4(Matrix4x4 * o)
{
    return new Matrix4x4(*o);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::new_Matrix4x4(PyObject * o)
{
    std::vector<std::vector<double>> vecs = PythonAPI::get()->toVecOfVecDouble(o);
    return new Matrix4x4(vecs);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix4x4::delete_Matrix4x4(Matrix4x4 * m)
{
    delete m;
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix4x4::at(Matrix4x4 * m, int row, int col)
{
    return m->at(row, col);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyMatrix4x4::column(Matrix4x4 * m, int idx)
{
    return new Vector4(m->getColumn(idx));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::transposed(Matrix4x4 * m)
{
    return new Matrix4x4(m->transposed());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix4x4::set_to_identity(Matrix4x4 * m)
{
    m->setToIdentity();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector4 * PyMatrix4x4::diagonal(Matrix4x4 * m)
{
    return new Vector4(m->diagonal());
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::transpose_multiply(Matrix4x4 * m, Matrix4x4 * m2)
{
    return new Matrix4x4(m->transposeMultiply(*m2));
}

/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix4x4::add_scale(Matrix4x4 * m, Vector3 * scale)
{
    m->addScale(*scale);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix4x4::add_rotation(Matrix4x4 * m, Vector3 * axis, double angle)
{
    m->addRotate(*axis, angle);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyMatrix4x4::translation_vec(Matrix4x4 * m)
{
    return new Vector3(m->getTranslationVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyMatrix4x4::set_translation_vec(Matrix4x4 * m, Vector3* vec)
{
    m->setTranslation(*vec);
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyMatrix4x4::determinant(Matrix4x4 * m)
{
    return m->determinant();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::inversed(Matrix4x4 * m)
{
    return new Matrix4x4(std::move(m->inversed()));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMatrix4x4::__eq__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return *m == *m2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__add__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return new Matrix4x4((*m) + *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__add__(Matrix4x4 * m, PyObject * p2)
{
    Matrix4x4 m2 = Matrix4x4(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix4x4((*m) + m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__sub__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return new Matrix4x4((*m) - *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__sub__(Matrix4x4 * m, PyObject * p2)
{
    Matrix4x4 m2 = Matrix4x4(PythonAPI::get()->toVecOfVecDouble(p2));
    return new Matrix4x4((*m) - m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__mul__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return new Matrix4x4((*m) * (*m2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__mul__(Matrix4x4 * m, double f)
{
    return new Matrix4x4((*m) * f);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__mul__(Matrix4x4 * m, int f)
{
    return new Matrix4x4((*m) * double(f));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__mul__(Matrix4x4 * m, PyObject * o)
{
    if (PythonAPI::get()->isListLike(o)) {
        // If multiplying by a vector of vectors
        Matrix4x4 m2 = Matrix4x4(PythonAPI::get()->toVecOfVecDouble(o));
        return new Matrix4x4((*m) * m2);
    }
    else {
        // If multiplying by a value
        return new Matrix4x4(*m * PythonAPI::get()->toDouble(o));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__iadd__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__isub__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return &(*m += *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Matrix4x4 * PyMatrix4x4::__imul__(Matrix4x4 * m, Matrix4x4 * m2)
{
    return &(*m -= *m2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyMatrix4x4::to_list(Matrix4x4 * m) const
{
    return PythonAPI::get()->toPyTuple(m->asStdVector());

}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyMatrix4x4::py_toString(Matrix4x4 * m)
{
    return QString(*m);
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyScenario
/////////////////////////////////////////////////////////////////////////////////////////////
PyScenario::PyScenario()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////
QString PyScenario::py_toString(Scenario* s)
{
    return s->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyScene
/////////////////////////////////////////////////////////////////////////////////////////////
PyScene::PyScene()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////
QString PyScene::py_toString(Scene * s)
{
    return s->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PySceneObject
/////////////////////////////////////////////////////////////////////////////////////////////
PySceneObject::PySceneObject()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject* PySceneObject::new_SceneObject(Scene* scene)
{
    std::shared_ptr<Scene> scenePtr = scene->scenario()->getScene(scene->getUuid());
    auto object = SceneObject::create(scenePtr);
    object->setIsPythonGenerated(true);
    
    // Emit signal that scenario has changed
    emit object->engine()->scenarioChanged();

    return object.get();
}

/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject* PySceneObject::new_SceneObject(const QString& uuidStr)
{
    // TODO: Just use Uuid directly
    // Return a scene object from the given UUID str
    std::shared_ptr<SceneObject> object = SceneObject::get(uuidStr);
    return object.get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PySceneObject::delete_SceneObject(SceneObject* so)
{
    // Don't want scene objects implicitly going out of scope
    Q_UNUSED(so);
    //remove(so);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PySceneObject::get_name(SceneObject* object) const
{
    return object->getName();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PySceneObject::as_json_str(SceneObject * so) const
{
    QString strJson = JsonReader::getJsonValueAsQString(so->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
TransformComponent * PySceneObject::transform(SceneObject * so)
{
    return so->transform().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
CoreEngine * PySceneObject::engine(SceneObject * so)
{
    return so->engine();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Scene* PySceneObject::scene(SceneObject * object)
{
    return object->scene().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PySceneObject::remove(SceneObject* so)
{
    so->remove();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyLight
/////////////////////////////////////////////////////////////////////////////////////////////
PyLight::PyLight()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
Light * PyLight::new_Light(SceneObject* object)
{
    std::shared_ptr<SceneObject> objectShared = object->scene()->getSceneObject(object->getUuid());
    Light* l = new Light(objectShared);
    l->setIsPythonGenerated(true);
    return l;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyLight::delete_Light(Light * l)
{
    // Unnecessary, deleted upon SceneObject deletion
    Q_UNUSED(l);
    //delete l;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyLight::as_json_str(Light * l) const
{
    QString strJson = JsonReader::getJsonValueAsQString(l->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyLight::get_diffuse_color(Light * l)
{
    return PythonAPI::get()->toPyTuple(l->getDiffuseColor().toVector4i());
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyLight::get_ambient_color(Light * l)
{
    return PythonAPI::get()->toPyTuple(l->getAmbientColor().toVector4i());
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyLight::get_specular_color(Light * l)
{
    return PythonAPI::get()->toPyTuple(l->getSpecularColor().toVector4i());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyLight::set_diffuse_color(Light * l, PyObject* color)
{
    std::vector<int> vec = PythonAPI::get()->toVecInt(color);
    Color c(vec);
    l->setDiffuseColor(c);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyLight::set_ambient_color(Light * l, PyObject* color)
{
    std::vector<int> vec = PythonAPI::get()->toVecInt(color);
    Color c(vec);
    l->setAmbientColor(c);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyLight::set_specular_color(Light * l, PyObject* color)
{
    std::vector<int> vec = PythonAPI::get()->toVecInt(color);
    Color c(vec);
    l->setSpecularColor(c);
}
/////////////////////////////////////////////////////////////////////////////////////////////
double PyLight::get_intensity(Light * l)
{
    return l->getIntensity();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyLight::set_intensity(Light * l, PyObject* intensity)
{
    double i = PythonAPI::get()->toDouble(intensity);
    l->setIntensity(i);
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyLight::scene_object(Light * l) const
{
    //const QString& uuid = l->sceneObject()->getUuid().asString();
    return l->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyLight::py_toString(Light * l)
{
    return l->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyRenderer
/////////////////////////////////////////////////////////////////////////////////////////////
PyRenderer::PyRenderer()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
RendererComponent* PyRenderer::new_RendererComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    RendererComponent* r = new RendererComponent(objectShared);
    r->setIsPythonGenerated(true);
    return r;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyRenderer::delete_RendererComponent(RendererComponent* r)
{
    delete r;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyRenderer::as_json_str(RendererComponent* r) const
{
    QString strJson = JsonReader::getJsonValueAsQString(r->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyRenderer::py_toString(RendererComponent* r)
{
    return r->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyCamera
/////////////////////////////////////////////////////////////////////////////////////////////
PyCamera::PyCamera()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
CameraComponent* PyCamera::new_CameraComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    CameraComponent* c = new CameraComponent(objectShared);
    c->setIsPythonGenerated(true);
    return c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::delete_CameraComponent(CameraComponent * c)
{
    delete c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyCamera::as_json_str(CameraComponent * c) const
{
    QString strJson = JsonReader::getJsonValueAsQString(c->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyCamera::scene_object(CameraComponent * c) const
{
    return c->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_viewport(CameraComponent* c, double x, double y, double w, double h)
{
    c->camera().viewport().m_xn = x;
    c->camera().viewport().m_yn = y;
    c->camera().viewport().m_width = w;
    c->camera().viewport().m_height = h;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_depth(CameraComponent* c, int x)
{
    c->camera().viewport().m_depth = x;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCamera::set_fov(CameraComponent * c, double fov)
{
    c->camera().renderProjection().setFOV(fov);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyCamera::py_toString(CameraComponent * c)
{
    return c->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
// PyCharacterController
/////////////////////////////////////////////////////////////////////////////////////////////
PyCharacterController::PyCharacterController()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyCharacterController::~PyCharacterController()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::move(CharControlComponent * c, const Vector3 * disp) const
{
    c->move(*disp);
}
/////////////////////////////////////////////////////////////////////////////////////////////
float PyCharacterController::get_radius(CharControlComponent * c) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        return std::static_pointer_cast<CapsuleController>(c->controller())->getRadius();
    }
    else {
        return -1;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyCharacterController::set_radius(CharControlComponent * c, float rad) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        bool done = std::static_pointer_cast<CapsuleController>(c->controller())->setRadius(rad);
        return done;
    }
    else {
        return false;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
float PyCharacterController::get_height(CharControlComponent * c) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        return std::static_pointer_cast<CapsuleController>(c->controller())->getHeight();
    }
    else {
        return std::static_pointer_cast<BoxController>(c->controller())->getHalfHeight() * 2.0f;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyCharacterController::set_height(CharControlComponent * c, float height) const
{
    if (c->controller()->getType() == ControllerDescription::ControllerType::kCapsule) {
        bool done = std::static_pointer_cast<CapsuleController>(c->controller())->setHeight(height);
        return done;
    }
    else {
        return std::static_pointer_cast<BoxController>(c->controller())->setHalfHeight(height / 2.0f);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::set_height_offset(CharControlComponent * c, float offset) const
{
    c->controller()->setHeightOffset(offset);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::set_initial_position(CharControlComponent * c, const Vector3* pos) const
{
    c->controller()->setInitialPosition(*pos);
}
/////////////////////////////////////////////////////////////////////////////////////////////
CharControlComponent* PyCharacterController::new_CharControlComponent(SceneObject* so)
{
    std::shared_ptr<SceneObject> objectShared = so->scene()->getSceneObject(so->getUuid());
    CharControlComponent* c = new CharControlComponent(objectShared);
    c->setIsPythonGenerated(true);
    return c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyCharacterController::delete_CharControlComponent(CharControlComponent * c)
{
    delete c;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyCharacterController::as_json_str(CharControlComponent * c) const
{
    QString strJson = JsonReader::getJsonValueAsQString(c->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyCharacterController::scene_object(CharControlComponent * c) const
{
    return c->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyCharacterController::py_toString(CharControlComponent * c)
{
    return c->asQString();
}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyTransformComponent
/////////////////////////////////////////////////////////////////////////////////////////////
PyTransformComponent::PyTransformComponent() {

}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyTransformComponent::as_json_str(TransformComponent * t) const
{
    QString strJson = JsonReader::getJsonValueAsQString(t->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
TranslationComponent * PyTransformComponent::translation(TransformComponent * t)
{
    return &(t->translation());
}
/////////////////////////////////////////////////////////////////////////////////////////////
RotationComponent * PyTransformComponent::rotation(TransformComponent * r)
{
    return &(r->rotation());
}
/////////////////////////////////////////////////////////////////////////////////////////////
ScaleComponent * PyTransformComponent::scale(TransformComponent * s)
{
    return &(s->scale());
}
/////////////////////////////////////////////////////////////////////////////////////////////
SceneObject * PyTransformComponent::scene_object(TransformComponent * t) const
{
    return t->sceneObject().get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyTransformComponent::py_toString(TransformComponent * t)
{
    return t->Object::asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// PyTranslationComponent
/////////////////////////////////////////////////////////////////////////////////////////////
PyTranslationComponent::PyTranslationComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyTranslationComponent::as_json_str(TranslationComponent * t) const
{
    QString strJson = JsonReader::getJsonValueAsQString(t->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
const Vector3* PyTranslationComponent::get_position(TranslationComponent * t) const
{
    return &(t->getPosition());
    //return PythonAPI::get()->toPyTuple(t->getPosition().asStdVector());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTranslationComponent::set_position(TranslationComponent * t, Vector3 * pos)
{
    t->setPosition(*pos);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyTranslationComponent::set_position(TranslationComponent* t, PyObject* position)
{
    // See: https://sourceforge.net/p/pythonqt/discussion/631393/thread/cf43961596/?limit=25#04ef
    // But yes, you can do a type check for PythonQt
    // wrappers and get the wrapped ptr from a wrapper.There is no example, but
    // you can see it in PythonQtConversion and PythonQtClassInfo how to do this.
    if (PythonAPI::get()->isListLike(position)) {
        std::vector<double> pVec = PythonAPI::get()->toVecDouble(position);
        t->setPosition(pVec);

    }
    else {
        QString className = PythonAPI::get()->getClassName(position);
#ifdef DEBUG_MODE
        throw("Error, position type not recognized");
#endif
        QString stdErr = PythonAPI::get()->printAndClearErrors();
        logError("set_position:: Error, position type " + className + " not recognized: " + stdErr);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////
//const Vector3 * PyTranslationComponent::get_velocity(TranslationComponent * t) const
//{
//    return &(t->getVelocity());
//    //return PythonAPI::get()->toPyTuple(t->getVelocity().asStdVector());
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_velocity(TranslationComponent * t, Vector3 * vel)
//{
//    t->setVelocity(*vel);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_velocity(TranslationComponent* t, PyObject* vel)
//{
//    std::vector<double> vVec = PythonAPI::get()->toVecDouble(vel);
//    t->setVelocity(vVec);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//const Vector3 * PyTranslationComponent::get_acceleration(TranslationComponent * t) const
//{
//    return &(t->getAcceleration());
//    //return PythonAPI::get()->toPyTuple(t->getAcceleration().asStdVector());
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_acceleration(TranslationComponent * t, Vector3 * acc)
//{
//    t->setAcceleration(*acc);
//}
///////////////////////////////////////////////////////////////////////////////////////////////
//void PyTranslationComponent::set_acceleration(TranslationComponent* t, PyObject* acc)
//{
//    std::vector<double> aVec = PythonAPI::get()->toVecDouble(acc);
//    t->setAcceleration(aVec);
//}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyTranslationComponent::py_toString(TranslationComponent * t)
{
    return t->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Quaternion
/////////////////////////////////////////////////////////////////////////////////////////////
PyQuaternion::PyQuaternion() {

}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion* PyQuaternion::new_Quaternion() {
    return new Quaternion();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion* PyQuaternion::new_Quaternion(double x, double y, double z, double w) {
    return new Quaternion(x, y, z, w);
}
///////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::new_Quaternion(double roll, double pitch, double yaw)
{
    return new Quaternion(roll, pitch, yaw);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_look_rotation(const Vector3* dir, const Vector3* up)
{
    return new Quaternion(std::move(Quaternion::fromDirection(dir->asReal(), up->asReal())));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::static_Quaternion_slerp(const Quaternion * q1, const Quaternion * q2, double factor)
{
    return new Quaternion(std::move(Quaternion::slerp(*q1, *q2, factor)));
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyQuaternion::delete_Quaternion(Quaternion * q)
{
    delete q;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyQuaternion::py_toString(Quaternion * q)
{
    QJsonArray arr = q->asJson().toArray();
    QJsonDocument doc(arr);
    QString strJson(doc.toJson(QJsonDocument::Compact));
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyQuaternion::__eq__(Quaternion * q, Quaternion* q2)
{
    return *q == *q2;
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__add__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion((*q) + *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__sub__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion(*q - *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__mul__(Quaternion * q, Quaternion* q2)
{
    return new Quaternion((*q) * (*q2));
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__iadd__(Quaternion * q, Quaternion* q2)
{
    return &(*q += *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__isub__(Quaternion * q, Quaternion* q2)
{
    return &(*q -= *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
Quaternion * PyQuaternion::__imul__(Quaternion * q, Quaternion* q2)
{
    return &(*q *= *q2);
}
/////////////////////////////////////////////////////////////////////////////////////////////
int PyQuaternion::norm(Quaternion * q) const
{
    return q->length();
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Quaternion
/////////////////////////////////////////////////////////////////////////////////////////////
PyEulerAngles::PyEulerAngles() {

}
///////////////////////////////////////////////////////////////////////////////////////////
EulerAngles * PyEulerAngles::new_EulerAngles(float ax, float ay, float az, PyObject* rotationOrder, int rotationType)
{
    EulerAngles::Axes axes = toAxes(rotationOrder);
    return new EulerAngles(ax, ay, az, axes, RotationType(rotationType));
}
/////////////////////////////////////////////////////////////////////////////////////////////
EulerAngles::Axes PyEulerAngles::toAxes(PyObject * o)
{
    std::vector<int> vec = PythonAPI::get()->toVecInt(o);
    EulerAngles::Axes axes;
    for (size_t i = 0; i < vec.size(); i++) {
        axes[i] = Axis(vec[i]);
    }
    return axes;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyEulerAngles::delete_EulerAngles(EulerAngles * q)
{
    delete q;
}




/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Rotation Component
/////////////////////////////////////////////////////////////////////////////////////////////
PyRotationComponent::PyRotationComponent()
{
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::add_rotation(RotationComponent* r, const EulerAngles& eulerAngles)
{
    return r->addRotation(eulerAngles);
}
///////////////////////////////////////////////////////////////////////////////////////////
const Quaternion * PyRotationComponent::get_quaternion(RotationComponent * r) const
{
    return &r->getQuaternion();
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::set_rotation(RotationComponent* r, Quaternion * quaternion)
{
    return r->setRotation(*quaternion);
}
///////////////////////////////////////////////////////////////////////////////////////////
void PyRotationComponent::set_rotation(RotationComponent* r, const EulerAngles& eulerAngles)
{
    return r->setRotation(eulerAngles);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyRotationComponent::as_json_str(RotationComponent * r) const
{
    QString strJson = JsonReader::getJsonValueAsQString(r->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyRotationComponent::py_toString(RotationComponent * r)
{
    return r->asQString();
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// ShaderProgram
/////////////////////////////////////////////////////////////////////////////////////////////
PyShaderProgram::PyShaderProgram() 
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
const ShaderProgram* PyShaderProgram::new_ShaderProgram(ResourceCache* cache, const QString& vertPath, const QString& fragPath) {
    return cache->getShaderProgramByFilePath(vertPath, fragPath).get();
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderProgram::delete_ShaderProgram(ShaderProgram* s) {
    Q_UNUSED(s);
    //delete s;
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject * PyShaderProgram::get_uniform(ShaderProgram* s, const QString& uniformName)
{
    const Uniform* uniformPtr = s->getUniformValue(uniformName);
    if (!uniformPtr) {
        throw("Error, uniform not found");
    }
    const Uniform& uniform = *uniformPtr;
    return uniformToPyObject(uniform);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderProgram::set_uniform(ShaderProgram * s, const QString & uniformName, Matrix2x2 * value)
{
    s->setUniformValue(uniformName, value->toRealMatrix());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderProgram::set_uniform(ShaderProgram * s, const QString & uniformName, Matrix3x3 * value)
{
    s->setUniformValue(uniformName, value->toRealMatrix());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderProgram::set_uniform(ShaderProgram * s, const QString & uniformName, Matrix4x4 * value)
{
    s->setUniformValue(uniformName, value->toRealMatrix());
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyShaderProgram::set_uniform(ShaderProgram* s, const QString & uniformName, PyObject * value)
{
    // Convert to uniform 
    QVariant variant = PythonAPI::get()->toQVariant(value);
    if (!variant.isValid()) {
        throw("type not handled");
    }
    s->setUniformValue(uniformName, variant);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyShaderProgram::as_json_str(ShaderProgram * s) const
{
    QString strJson = JsonReader::getJsonValueAsQString(s->asJson());
    return strJson;
}

/////////////////////////////////////////////////////////////////////////////////////////////
QString PyShaderProgram::py_toString(ShaderProgram * s)
{
    return s->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject* PyShaderProgram::uniformToPyObject(const Uniform & uniform)
{
    PythonAPI* api = PythonAPI::get();
    PyObject* po;
    if (uniform.is<int>()) {
        po = api->toPyLon(uniform.get<int>());
    }
    else if (uniform.is<bool>()) {
        po = api->toPyBool(uniform.get<bool>());
    }
    else if (uniform.is<real_g>()) {
        po = api->toPyFloat(uniform.get<real_g>());
    }
    else if (uniform.is<Vector2g>()) {
        po = api->toPyTuple(uniform.get<Vector2g>().asStdVector());
    }
    else if (uniform.is<Vector3g>()) {
        po = api->toPyTuple(uniform.get<Vector3g>().asStdVector());
    }
    else if (uniform.is<Vector4g>()) {
        po = api->toPyTuple(uniform.get<Vector4g>().asStdVector());
    }
    else if (uniform.is<Matrix2x2g>()) {
        po = api->toPyTuple(uniform.get<Matrix2x2g>().asStdVector());
    }
    else if (uniform.is<Matrix3x3g>()) {
        po = api->toPyTuple(uniform.get<Matrix3x3g>().asStdVector());
    }
    else if (uniform.is<Matrix4x4g>()) {
        po = api->toPyTuple(uniform.get<Matrix4x4g>().asStdVector());
    }
    else if (uniform.is<std::vector<real_g>>()) {
        po = api->toPyTuple(uniform.get<std::vector<real_g>>());
    }
    else if (uniform.is<Vec3List>()) {
        std::vector<std::vector<real_g>> vecs;
        for (const Vector3g& vec : uniform.get<Vec3List>()) {
            Vec::EmplaceBack(vecs, vec.asStdVector());
        }
        po = api->toPyTuple(vecs);
    }
    else {
#ifdef DEBUG_MODE
        QString err = "Error, this uniform to PyObject conversion is not supported";
        QString typeName = QString::fromStdString(uniform.typeInfo().name());
        err += ": " + typeName;
        qDebug() << err;
        po = nullptr;
#endif
    }

    return po;
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Scale Component
/////////////////////////////////////////////////////////////////////////////////////////////
PyScaleComponent::PyScaleComponent()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
PyObject* PyScaleComponent::get_scale(ScaleComponent* s) const
{
    PyObject* scale = PythonAPI::get()->toPyTuple(s->getScale());
    return scale;
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent * s, Vector3 * scale)
{
    s->setScale(*scale);
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent* s, PyObject * scale)
{
    s->setScale(PythonAPI::get()->toVecDouble(scale));
}
/////////////////////////////////////////////////////////////////////////////////////////////
void PyScaleComponent::set_scale(ScaleComponent* s, double x, double y, double z)
{
    s->setScale(x, y, z);
}
/////////////////////////////////////////////////////////////////////////////////////////////
QJsonValue PyScaleComponent::as_json_str(ScaleComponent * s) const
{
    QString strJson = JsonReader::getJsonValueAsQString(s->asJson());
    return strJson;
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyScaleComponent::py_toString(ScaleComponent * s)
{
    return s->asQString();
}



/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Input handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyInputHandler::PyInputHandler()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
KeyHandler * PyInputHandler::key_handler(InputHandler * ih)
{
    return &(ih->keyHandler());
}
/////////////////////////////////////////////////////////////////////////////////////////////
MouseHandler * PyInputHandler::mouse_handler(InputHandler * ih)
{
    return &(ih->mouseHandler());
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyInputHandler::py_toString(InputHandler * ih)
{
    return ih->asQString();
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Key handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyKeyHandler::PyKeyHandler()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////
QString PyKeyHandler::py_toString(KeyHandler * ih)
{
    return ih->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_pressed(KeyHandler* kh, int key)
{
    return kh->wasPressed(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_pressed(KeyHandler* kh, const QString & key)
{
    return kh->wasPressed(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_released(KeyHandler* kh, int key)
{
    return kh->wasReleased(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_released(KeyHandler* kh, const QString & key)
{
    return kh->wasReleased(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_double_clicked(KeyHandler* kh, int key)
{
    return kh->wasDoubleClicked(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::was_double_clicked(KeyHandler* kh, const QString & key)
{
    return kh->wasDoubleClicked(key);
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::is_held(KeyHandler* kh, int key) const
{
    return kh->isHeld(Qt::Key(key));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyKeyHandler::is_held(KeyHandler* kh, const QString & key)
{
    return kh->isHeld(key);
}


/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// Mouse handler
/////////////////////////////////////////////////////////////////////////////////////////////
PyMouseHandler::PyMouseHandler()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////
QString PyMouseHandler::py_toString(MouseHandler * ih)
{
    return ih->asQString();
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_pressed(MouseHandler* mh, int btn)
{
    return mh->wasPressed(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_released(MouseHandler* mh, int btn)
{
    return mh->wasReleased(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::was_double_clicked(MouseHandler* mh, int btn)
{
    return mh->wasDoubleClicked(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::is_held(MouseHandler* mh, int btn)
{
    return mh->isHeld(Qt::MouseButton(btn));
}
/////////////////////////////////////////////////////////////////////////////////////////////
bool PyMouseHandler::moved(MouseHandler * mh)
{
    return mh->wasMoved();
}
/////////////////////////////////////////////////////////////////////////////////////////////
Vector3 * PyMouseHandler::screen_pos(MouseHandler * mh)
{
    Vector2g pos = mh->normalizeMousePosition();
    return new Vector3(pos[0], pos[1], 0.0);
}



/////////////////////////////////////////////////////////////////////////////////////////////
} // End namespaces

