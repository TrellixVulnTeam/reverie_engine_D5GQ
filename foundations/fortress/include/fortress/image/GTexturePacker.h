/////////////////////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////////////////////

#ifndef GB_TEXTURE_PACKER
#define GB_TEXTURE_PACKER

// QT

// Internal
#include "fortress/image/GImage.h"
#include "fortress/containers/math/GVector.h"

namespace rev {


/////////////////////////////////////////////////////////////////////////////////////////////
// Forward Declarations
/////////////////////////////////////////////////////////////////////////////////////////////
class Image;

/////////////////////////////////////////////////////////////////////////////////////////////
// Class definitions
/////////////////////////////////////////////////////////////////////////////////////////////

struct TextureNode
{
    TextureNode() {}
    TextureNode(const Vector<int, 2>& origin, const Vector<int, 2>& size) :
        m_origin(origin),
        m_size(size) {
        m_empty = true;
    }

    Vector<int, 2> m_origin; // Top left of the rectangle this node represents

    /// @brief  Size of the rectangle this node represents, bytes per line and number of lines
    Vector<int, 2> m_size;   
    bool m_empty;        // true if this node is a leaf and is filled

    std::unique_ptr<TextureNode> m_left;  // Left (or top) subdivision
    std::unique_ptr<TextureNode> m_right; // Right (or bottom) subdivision
};

/// @brief Metadata describing a node added to the texturePacker
struct PackedTextureInfo {
    Vector<int, 2> m_origin;
    Vector<int, 2> m_size;
};

/// @brief Struct containing info describing a sprite sheet
/// @details For use as custom user data
struct SpriteSheetInfo {
    std::vector<PackedTextureInfo> m_packedTextures;

    /// @brief Convert from the given class type to JSON
    /// @note Actually defined in namespace outside of class, so this should be recognized by nlohmann JSON
    /// @param orJson The output JSON
    /// @param korObject The object to convert to JSON
    friend void to_json(nlohmann::json& orJson, const SpriteSheetInfo& korObject);

    /// @brief Convert from JSON to the given class type
    /// @param korJson The input JSON
    /// @param orObject The object to be obtained from JSON
    friend void from_json(const nlohmann::json& korJson, SpriteSheetInfo& orObject);

};


/// @class TexturePacker
/// @brief Helper class for generating bitmaps
/// @see https://straypixels.net/texture-packing-for-fonts/
/// @see https://blackpawn.com/texts/lightmaps/default.html
/// @see https://github.com/Chaosed0/SpiderGame/blob/f2ba2199de5df5468f60f46708db1af75c872de1/Engine/src/Renderer/TexturePacker.h
class TexturePacker{
public:
    //--------------------------------------------------------------------------------------------
    /// @name Static
    /// @{

    /// @}

	//--------------------------------------------------------------------------------------------
	/// @name Constructors/Destructor
	/// @{
    TexturePacker(Image::ColorFormat format = Image::ColorFormat::kGrayscale8);
    TexturePacker(const Vector<int, 2>& initialSize, Uint32_t pixelByteCount = 1, Image::ColorFormat format = Image::ColorFormat::kGrayscale8);
    ~TexturePacker();

	/// @}

	//--------------------------------------------------------------------------------------------
	/// @name Public Methods
	/// @{

    /// @brief Pack a texture, i.e. adds it to the current buffer, given a buffer and size
    /// @returns The origin (bottom-left corner) of the added image in the texture
    PackedTextureInfo packTexture(const Image& image);
    PackedTextureInfo packTexture(const unsigned char* textureBuffer, int bufferWidth, int bufferHeight);
    PackedTextureInfo packTexture(const unsigned char* textureBuffer, const Vector<int, 2>& bufferSize);

    /// @brief Return the buffer generated by the backing algorithm
    const unsigned char* getBuffer() const;

    /// @brief Returns an image representing the buffer
    /// @details The texture packer, i.e. the underlying buffer, must 
    /// remain valid through the life of the image
    Image getImage() const;

    /// @brief Returns a copy of the image in the given format
    /// @note This image duplicates the buffer, so the texture packer can go out of scope before the image
    Image getImage(Image::ColorFormat format) const;

    /// @brief Return the dimensions of the internal texture in pixels
    Vector2i getTextureSize() const;

	/// @}

protected:
    //--------------------------------------------------------------------------------------------
    /// @name Protected Methods
    /// @{

    /// @brief Algorithm to find space within a tree for a new texture
    TextureNode* TexturePacker::pack(TextureNode* node, const Vector<int, 2>& size);

    /// @brief Resize buffer
    void resizeBuffer(Uint32_t bytesPerLine, Uint32_t numLines/*, Uint32_t pixelWidth*/);

    /// @brief Get buffer size in bytes
    size_t getBufferSize() const;

    /// @brief Get padding in number of bytes
    Uint32_t getBytePadding() const;

    /// @}

    //--------------------------------------------------------------------------------------------
    /// @name Protected members
    /// @{

    /// @brief The root node of the packing tree
    std::unique_ptr<TextureNode> m_rootNode;

    /// @brief The actual buffer (bitmap) being generated
    std::vector<Uint8_t> m_buffer;

    /// @brief The number of bytes per line in the texture
    /// @details The pixel size (in bytes) is obtained via m_bytesPerLine / m_textureSize[0]
    Uint32_t m_bytesPerLine;

    /// @brief The number of lines in the buffer
    Uint32_t m_numLines;
    
    /// @brief The number of bytes per pixel
    //Uint8_t m_pixelWidth;

    /// @brief The padding between textures, in number of pixels
    Uint8_t m_paddingPixels;

    /// @brief The image format of the buffer (if specified via packed imaged)
    Image::ColorFormat m_format = Image::ColorFormat::kInvalid;

    /// @}
};


/////////////////////////////////////////////////////////////////////////////////////////////
} // End namespaces

#endif