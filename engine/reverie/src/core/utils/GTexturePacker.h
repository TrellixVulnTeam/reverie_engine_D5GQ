/////////////////////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////////////////////

#ifndef GB_TEXTURE_PACKER
#define GB_TEXTURE_PACKER

// QT

// Internal
#include "../GObject.h"
#include "../resource/GImage.h"
#include "../geometry/GVector.h"

namespace rev {


/////////////////////////////////////////////////////////////////////////////////////////////
// Forward Declarations
/////////////////////////////////////////////////////////////////////////////////////////////
class Image;

/////////////////////////////////////////////////////////////////////////////////////////////
// Class definitions
/////////////////////////////////////////////////////////////////////////////////////////////


/// @class TexturePacker
/// @brief Helper class for generating bitmaps
/// See: https://straypixels.net/texture-packing-for-fonts/
/// https://blackpawn.com/texts/lightmaps/default.html
/// https://github.com/Chaosed0/SpiderGame/blob/f2ba2199de5df5468f60f46708db1af75c872de1/Engine/src/Renderer/TexturePacker.h
class TexturePacker : public Object {
public:
    //--------------------------------------------------------------------------------------------
    /// @name Static
    /// @{

    /// @}

	//--------------------------------------------------------------------------------------------
	/// @name Constructors/Destructor
	/// @{
    TexturePacker();
    TexturePacker(const Vector<int, 2>& initialSize);
    ~TexturePacker();

	/// @}

	//--------------------------------------------------------------------------------------------
	/// @name Public Methods
	/// @{

    /// @brief Pack a texture, i.e. adds it to the current buffer, given a buffer and size
    Vector<int, 2> packTexture(const Image& image);
    Vector<int, 2> packTexture(const unsigned char* textureBuffer, int bufferWidth, int bufferHeight);
    Vector<int, 2> packTexture(const unsigned char* textureBuffer, const Vector<int, 2>& bufferSize);

    /// @brief Return the final size of the generated bitmap texture
    const Vector<int, 2>& getTextureSize() const;

    /// @brief Return the buffer generated by the backing algorithm
    const unsigned char* getBuffer() const;

    /// @brief Returns an image representing the buffer
    /// @details The texture packer, i.e. the underlying buffer, must 
    /// remain valid through the life of the image
    Image getImage(QImage::Format format) const;
    Image getImage() const;

	/// @}

protected:

    struct TextureNode
    {
        TextureNode() {}
        TextureNode(const Vector<int, 2>& origin, const Vector<int, 2>& size):
            m_origin(origin), 
            m_size(size) {
            m_empty = true;
        }

        Vector<int, 2> m_origin; // Top left of the rectangle this node represents
        Vector<int, 2> m_size;   // Size of the rectangle this node represents
        bool m_empty;        // true if this node is a leaf and is filled

        std::unique_ptr<TextureNode> m_left;  // Left (or top) subdivision
        std::unique_ptr<TextureNode> m_right; // Right (or bottom) subdivision
    };

    //--------------------------------------------------------------------------------------------
    /// @name Protected Methods
    /// @{

    /// @brief Algorithm to find space within a tree for a new texture
    TextureNode* TexturePacker::pack(TextureNode* node, const Vector<int, 2>& size);

    /// @brief Resize buffer
    void resizeBuffer(const Vector<int, 2>& newSize);

    /// @brief Get buffer size in bytes
    unsigned long getBufferSize() const;

    /// @}

    //--------------------------------------------------------------------------------------------
    /// @name Protected members
    /// @{

    /// @brief The root node of the packing tree
    std::unique_ptr<TextureNode> m_rootNode;

    /// @brief The actual buffer (bitmap) being generated
    std::vector<unsigned char> m_buffer;

    /// @brief The size of the texture being generated
    Vector<int, 2> m_textureSize;

    /// @brief The padding between textures
    int m_padding;

    /// @brief The image format of the buffer (if specified via packed imaged)
    QImage::Format m_format = QImage::Format::Format_Invalid;

    /// @}
};


/////////////////////////////////////////////////////////////////////////////////////////////
} // End namespaces

#endif